[{"categories":"å­¦ä¹ ç¬”è®°","contents":"ç‚¹åˆ†æ²»ï¼Œå¤–å›½äººç§°ä¹‹ä¸º Centroid decompositionï¼Œé‡å¿ƒåˆ†è§£ã€‚\nä½•ä¸ºæ ‘çš„é‡å¿ƒ å­¦ä¹ é‡å¿ƒåˆ†è§£ä¹‹å‰ï¼Œè‡ªç„¶è¦å…ˆäº†è§£é‡å¿ƒã€‚\nä¸‹é¢ç»Ÿä¸€ç”¨ $n$ è¡¨ç¤ºæ ‘ä¸Šç»“ç‚¹çš„ä¸ªæ•°ã€‚\nåœ¨ä¸€æ£µæ ‘ä¸­ï¼Œå¦‚æœåˆ é™¤ä¸€ä¸ªé¡¶ç‚¹åå¾—åˆ°çš„æœ€å¤§å­æ ‘çš„é¡¶ç‚¹æ•°æœ€å°‘ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯æ ‘çš„é‡å¿ƒï¼ˆCentroidï¼‰ã€‚\né‡å¿ƒçš„æ€§è´¨ï¼š\nåˆ é™¤é‡å¿ƒåå¾—åˆ°çš„æ‰€æœ‰å­æ ‘ï¼Œå…¶é¡¶ç‚¹æ•°å¿…ç„¶ä¸è¶…è¿‡ $n/2$ã€‚\nè¯æ˜ï¼šé€‰å–ä»»æ„é¡¶ç‚¹ä½œä¸ºèµ·ç‚¹ï¼Œæ¯æ¬¡éƒ½æ²¿ç€è¾¹å‘æœ€å¤§å­æ ‘çš„æ–¹å‘ç§»åŠ¨ï¼Œæœ€ç»ˆä¸€å®šä¼šåˆ°è¾¾æŸä¸ªé¡¶ç‚¹ï¼Œå°†å…¶åˆ é™¤åå¾—åˆ°çš„æ‰€æœ‰å­æ ‘çš„é¡¶ç‚¹æ•°éƒ½ä¸è¶…è¿‡ $n/2$ã€‚å¦‚æœè¿™æ ·çš„ç‚¹å­˜åœ¨çš„è¯ï¼Œé‚£ä¹ˆä¹Ÿå°±å¯ä»¥è¯æ˜åˆ é™¤é‡å¿ƒåå¾—åˆ°çš„æ‰€æœ‰å­æ ‘çš„é¡¶ç‚¹æ•°éƒ½ä¸è¶…è¿‡ $n/2$ã€‚\nè®°å½“å‰é¡¶ç‚¹ä¸º $v$ï¼Œå¦‚æœé¡¶ç‚¹ $v$ å·²ç»æ»¡è¶³ä¸Šè¿°æ¡ä»¶åˆ™åœæ­¢ã€‚å¦åˆ™ï¼Œä¸é¡¶ç‚¹ $v$ é‚»æ¥çš„æŸä¸ªå­æ ‘çš„é¡¶ç‚¹æ•°å¿…ç„¶å¤§äº $n/2$ã€‚å‡è®¾é¡¶ç‚¹ $v$ ä¸è¯¥å­æ ‘ä¸­çš„é¡¶ç‚¹ $w$ é‚»æ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æŠŠé¡¶ç‚¹ $w$ ä½œä¸ºæ–°çš„é¡¶ç‚¹ $v$ã€‚ä¸æ–­é‡å¤è¿™ä¸€æ­¥éª¤ï¼Œå¿…ç„¶ä¼šåœ¨æœ‰é™æ­¥åœæ­¢ã€‚è¿™æ˜¯å› ä¸ºå¯¹äºç§»åŠ¨ä¸­æ‰€ç”¨çš„è¾¹ $(v, w)$ï¼Œå¿…æœ‰ $v$ ä¾§çš„å­æ ‘çš„é¡¶ç‚¹æ•°å°äº $n/2$ï¼Œ$w$ ä¾§çš„å­æ ‘çš„é¡¶ç‚¹æ•°å¤§äº $n/2$ï¼Œæ‰€ä»¥ä¸å¯èƒ½å†ä» $w$ ç§»åŠ¨åˆ° $v$ã€‚å› è€Œè¯¥æ“ä½œæ°¸è¿œä¸ä¼šå›åˆ°å·²ç»ç»è¿‡çš„é¡¶ç‚¹ï¼Œè€Œé¡¶ç‚¹æ•°åˆæ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥ç®—æ³•å¿…ç„¶åœ¨æœ‰é™æ­¥ç»ˆæ­¢ã€‚\næ ‘ä¸­æ‰€æœ‰é¡¶ç‚¹åˆ°æŸä¸ªé¡¶ç‚¹çš„è·ç¦»å’Œä¸­ï¼Œåˆ°é‡å¿ƒçš„è·ç¦»å’Œæ˜¯æœ€å°çš„ï¼›å¦‚æœæœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆåˆ°å®ƒä»¬çš„è·ç¦»å’Œä¸€æ ·ã€‚\næŠŠä¸¤æ£µæ ‘é€šè¿‡ä¸€æ¡è¾¹ç›¸è¿å¾—åˆ°ä¸€æ£µæ–°çš„æ ‘ï¼Œé‚£ä¹ˆæ–°çš„æ ‘çš„é‡å¿ƒåœ¨è¿æ¥åŸæ¥ä¸¤æ£µæ ‘çš„é‡å¿ƒçš„è·¯å¾„ä¸Šã€‚\nåœ¨ä¸€æ£µæ ‘ä¸Šæ·»åŠ æˆ–åˆ é™¤ä¸€ä¸ªå¶å­ï¼Œé‚£ä¹ˆå®ƒçš„é‡å¿ƒæœ€å¤šåªç§»åŠ¨ä¸€æ¡è¾¹çš„è·ç¦»ã€‚\næ›´å¤šè¯æ˜è¯·è§ï¼šæ ‘çš„é‡å¿ƒçš„æ€§è´¨åŠå…¶è¯æ˜ - suxxsfe - åšå®¢å›­ (cnblogs.com)\nå¯»æ‰¾æ ‘çš„é‡å¿ƒ æ ¹æ®é‡å¿ƒçš„å®šä¹‰ï¼Œå…ˆä»¥ $1$ ä¸ºæ ¹è¿›è¡Œ DFSã€‚åœ¨é€’å½’ä¸­è®¡ç®—å­æ ‘å¤§å° $siz[u]$ï¼Œå¹¶æ±‚å‡ºæœ€å¤§çš„å­æ ‘çš„å¤§å° $maxs[u]$ï¼Œæ¯”è¾ƒå‡ºé‡å¿ƒ $centroid$ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void getCentroid(int u, int fa, int s) { siz[u] = 1; maxs[u] = 0; for (int i = head[u]; i != 0; i = nxt[i]) { if (to[i] == fa) continue; getCentroid(to[i], u, s); siz[u] += siz[to[i]]; maxs[u] = max(maxs[u], siz[to[i]]); } // â€œå‘ä¸Šâ€ çš„éƒ¨åˆ†ä¹Ÿæ˜¯è¯¥ç»“ç‚¹çš„å­æ ‘ maxs[u] = max(maxs[u], s - siz[u]); if (maxs[u] \u0026lt; maxs[centroid] || !centroid) centroid = u; } int main() { centroid = 0; getCentroid(1, 0, n); return 0; } æäº¤ï¼šCSES - Finding a Centroid\nç‚¹åˆ†æ²» æˆ‘ä»¬å¯ä»¥ç”¨ç‚¹åˆ†æ²»è§£å†³å…³äºç»Ÿè®¡æ ‘ä¸Šè·¯å¾„çš„é—®é¢˜ã€‚\nä¾‹ä¸€ Luogu P3806ã€æ¨¡æ¿ã€‘ç‚¹åˆ†æ²» 1ï¼šç»™å®šä¸€æ£µæœ‰ $n$ ä¸ªç‚¹çš„å¸¦è¾¹æƒæ ‘ï¼Œ$m$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡º $k$ï¼Œè¯¢é—®æ ‘ä¸Šè·ç¦»ä¸º $k$ çš„ç‚¹å¯¹æ˜¯å¦å­˜åœ¨ã€‚\n$n\\le 10000,m\\le 100,k\\le 10000000$\næš´åŠ›çš„åšæ³•è‡³å°‘éœ€è¦ $O(n^{2})$ï¼Œæ˜¾ç„¶ä¼šè¶…æ—¶ï¼Œæ‰€ä»¥è€ƒè™‘åˆ†æ²»ã€‚\nå¦‚ä½•åˆ†å‰²å‘¢ï¼Ÿå¦‚æœéšæ„é€‰æ‹©é¡¶ç‚¹çš„è¯ï¼Œé€’å½’çš„æ·±åº¦å¯èƒ½é€€åŒ–æˆ $O(n)$ã€‚è‹¥æˆ‘ä»¬æ¯æ¬¡é€‰æ‹©å­æ ‘çš„é‡å¿ƒä½œä¸ºæ–°çš„æ ¹ç»“ç‚¹ï¼Œå¯ä»¥è®©é€’å½’çš„å±‚æ•°æœ€å°‘ã€‚å› ä¸ºæ¯æ¬¡æ ‘çš„å¤§å°è‡³å°‘å‡åŠï¼Œæ‰€ä»¥é€’å½’çš„æ·±åº¦æ˜¯ $O(log n)$ã€‚\nè®¾å½“å‰çš„æ ¹ç»“ç‚¹æ˜¯ $rt$ã€‚\nå¯¹äºæ¯ä¸€æ¡è·¯å¾„ $(u, v)$ï¼Œå¿…ç„¶æ»¡è¶³ä»¥ä¸‹ä¸‰ç§æƒ…å†µä¹‹ä¸€ï¼š\né¡¶ç‚¹ $u, v$ åœ¨ $rt$ çš„åŒä¸€å­æ ‘å†…ã€‚ é¡¶ç‚¹ $u, v$ åˆ†åˆ«åœ¨ $rt$ çš„ä¸åŒå­æ ‘å†…ã€‚ é¡¶ç‚¹ $u, v$ å…¶ä¸­ä¸€ä¸ªæ˜¯ $rt$ã€‚ å¯¹äºç¬¬ (1) ç§æƒ…å†µï¼Œå¯ä»¥é€’å½’åè½¬åŒ–æˆå¦å¤–çš„æƒ…å†µã€‚å¯¹äºç¬¬ (2) ç§æƒ…å†µï¼Œä»é¡¶ç‚¹ $u$ åˆ°é¡¶ç‚¹ $v$ çš„è·¯å¾„å¿…ç„¶ç»è¿‡æ ¹ç»“ç‚¹ $rt$ï¼Œåªè¦æ±‚å‡ºæ¯ä¸ªé¡¶ç‚¹åˆ° $rt$ çš„è·ç¦»ï¼Œå°±å¯ä»¥ç»Ÿè®¡å‡ºç­”æ¡ˆã€‚å¯¹äºç¬¬ (3) ç§æƒ…å†µï¼Œå¯ä»¥æ·»åŠ ä¸€ä¸ªåˆ° $rt$ è·ç¦»ä¸º $0$ çš„é¡¶ç‚¹ï¼Œå°±è½¬åŒ–ä¸ºäº†ç¬¬ (2) ç§æƒ…å†µã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ç¬¬ (1) ç§æƒ…å†µä¸­ç»Ÿè®¡çš„åŒä¸€å­æ ‘çš„é¡¶ç‚¹å¯¹ï¼Œè¦é¿å…åœ¨ç¬¬ (2) ç§æƒ…å†µä¸­è¢«é‡å¤ç»Ÿè®¡ã€‚é€šè¿‡å®¹æ–¥å’Œç±»ä¼¼äºæ ‘ä¸ŠèƒŒåŒ…çš„æ–¹æ³•å¯ä»¥å»é‡ã€‚\næœ€åçš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlog^{2}n)$ã€‚\nRECORDã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 int n, m; int L, p; int centroid; bool vis[MAXN], cnt[MAXW], ans[MAXM]; int ask[MAXM]; vector\u0026lt; std::pair\u0026lt; int, int \u0026gt; \u0026gt; g[MAXN]; int dis[MAXN]; int siz[MAXN], maxs[MAXN]; void getCentroid(int u, int fa, int s) { siz[u] = 1; maxs[u] = 0; for (auto i : g[u]) { if (i.first == fa || vis[i.first]) continue; getCentroid(i.first, u, s); siz[u] += siz[i.first]; maxs[u] = std::max(maxs[u], siz[i.first]); } maxs[u] = std::max(maxs[u], s - siz[u]); if (maxs[u] \u0026lt; maxs[centroid] || !centroid) centroid = u; } // è·å–å­æ ‘ä¸­æ‰€æœ‰ç‚¹åˆ°é‡å¿ƒçš„è·ç¦» void getDis(int u, int fa, int d) { dis[p++] = d; for (auto i : g[u]) { if (i.first == fa || vis[i.first]) continue; getDis(i.first, u, d + i.second); } } void calc() { L = p = 0; cnt[0] = 1; // ç±»ä¼¼äºæ ‘ä¸ŠèƒŒåŒ… for (auto i : g[centroid]) { if (vis[i.first]) continue; getDis(i.first, centroid, i.second); // ä¸€æ£µä¸€æ£µå­æ ‘åˆå¹¶ï¼Œä¸ä¼šé‡å¤ç»Ÿè®¡ for (int i = L; i \u0026lt; p; i++) { for (int j = 0; j \u0026lt; m; j++) { if (dis[i] \u0026gt; ask[j]) continue; ans[j] |= cnt[ask[j] - dis[i]]; } } for (int j = L; j \u0026lt; p; j++) cnt[dis[j]] = 1; L = p; } // è¿˜åŸ cnt æ•°ç»„ for (int i = 0; i \u0026lt; p; i++) cnt[dis[i]] = 0; // ä¸èƒ½ç”¨ memset } void solve(int u, int size) { centroid = 0; getCentroid(u, -1, size); getCentroid(centroid, -1, size); // å†æ±‚ä¸€æ¬¡ sizï¼Œé˜²æ­¢åé¢æ‰¾é‡å¿ƒæ—¶å‡ºé”™ vis[centroid] = true; calc(); for (auto i : g[centroid]) { if (vis[i.first]) continue; solve(i.first, siz[i.first]); } } int main() { solve(1, n); for (int i = 0; i \u0026lt; m; i++) { if (ans[i]) cout \u0026lt;\u0026lt; \u0026#34;AYE\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NAY\\n\u0026#34;; } return 0; } éœ€è¦æ³¨æ„çš„ç»†èŠ‚ï¼š\nåˆ†æ²»çš„æ—¶å€™æ±‚å‡ºæ–°çš„é‡å¿ƒä¹‹åï¼Œä¹Ÿè¦å†æ¬¡æ±‚å­æ ‘ $siz$ã€‚\nè¯¦è§ï¼šä¸€ç§åŸºäºé”™è¯¯çš„å¯»æ‰¾é‡å¿ƒæ–¹æ³•çš„ç‚¹åˆ†æ²»çš„å¤æ‚åº¦åˆ†æ - åšå®¢ - liu_cheng_aoçš„åšå®¢ (uoj.ac)\nè´¦å· 920848348 è¯„è®ºï¼š\nå¯¹äºå¤§éƒ¨åˆ†ç‚¹åˆ†æ²»çš„ä»£ç ä¸­ï¼Œä¸èƒ½ç›´æ¥ size = siz[v]ï¼Œå¦åˆ™ä¼šå¯¼è‡´åé¢çš„é‡å¿ƒæ±‚é”™ï¼ˆå¯ä»¥ç”¨ä¸‹é¢çš„æ ·ä¾‹è¯•ä¸€ä¸‹ï¼Œç„¶åè¾“å‡ºé‡å¿ƒèŠ‚ç‚¹çœ‹ä¸€ä¸‹ï¼Œä½ ä¼šå‘ç°ä» $6$-\u0026gt;$3$ è¿™ä¸€å¤§å—çš„é‡å¿ƒåº”è¯¥æ˜¯ $2$ï¼Œè€Œä»£ç è¾“å‡ºæ˜¯ $1$ã€‚åŸå› åœ¨äºï¼š\nç”±äºä¸€å¼€å§‹ä» ç‚¹ $1$ å¼€å§‹æ‰¾æ•´æ£µæ ‘çš„é‡å¿ƒï¼Œæ­¤æ—¶çš„ $siz[u]$ è¡¨ç¤ºçš„ä»…ä»…æ˜¯ä»¥ 1 ä¸ºæ ¹ç»“ç‚¹çš„æ ‘ä¸­ï¼Œ$u$ çš„å­æ ‘å¤§å°ã€‚é‚£ä¹ˆç°åœ¨é‡å¿ƒ $root$ æ‰¾åˆ°äº†ï¼Œé‚£ä¹ˆä»è¿™æ•´æ£µæ ‘çš„é‡å¿ƒ $root$ å¼€å§‹æ·±æœæ—¶ï¼Œè‹¥æœ‰è¾¹ $root$-\u0026gt;$v$ ï¼Œè€Œæ­¤æ—¶çš„ $siz[v]$ çš„å€¼å¹¶ä¸æ˜¯ä»¥ $v$ ä¸ºæ ¹çš„å­æ ‘çš„å¤§å°ï¼ˆè¿™ä¸ªå­æ ‘å½“ç„¶ä¸åŒ…æ‹¬çˆ¶äº² $root$ é‚£ä¸€å—ï¼‰ã€‚å…·ä½“ä¸ºä»€ä¹ˆï¼Œè¿™é‡Œç»™ä¸€ç»„æ ·ä¾‹ï¼Œå¤§å®¶å¯ä»¥åœ¨å›¾ä¸­ç”»ä¸€ä¸‹ã€‚ æ­¤æ ·ä¾‹çš„å¯¹åº”é¢˜ç›®ä¸º Luogu P3806ã€æ¨¡æ¿ã€‘ç‚¹åˆ†æ²» 1ã€‚\nç„¶åæˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥æ¥ï¼š\nå…ˆä» $1$ å¼€å§‹ dfs ï¼Œç»Ÿè®¡ $siz$ æ•°ç»„ï¼Œæ­¤æ—¶å¾ˆæ¸…æ™°çš„çŸ¥é“ $siz[3] = 7$ ï¼Œå› ä¸ºæ˜¯ä»¥ $1$ ä¸ºæ ¹æ·±æœçš„ã€‚å¾ˆæ˜æ˜¾ï¼Œä¸€å¼€å§‹è¿™æ•´æ£µæ ‘çš„é‡å¿ƒæ˜¯ 6 å·èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼š\nå½“ä»ç‚¹ $6$ å¼€å§‹ dfs æ—¶ï¼Œæœ‰ $6$-\u0026gt;$3$ è¿™æ¡è¾¹ï¼Œé‚£ä¹ˆæŒ‰ç†æ¥è¯´ï¼Œ$size = siz[3]$ï¼Œæ­¤æ—¶ $size$ è¡¨ç¤ºçš„æ˜¯ä»¥ $3$ ä¸ºæ ¹çš„å­æ ‘çš„å¤§å°ï¼Œå¯çœ‹å›¾ä¸Šæ˜æ˜æ˜¯ $5$ å•Šï¼ˆåœ¨ç‚¹ $3$ çš„å·¦è¾¹ï¼Œä¸åŒ…å«ç‚¹ $6$ é‚£è¾¹ï¼‰ã€‚å¯æ˜¯æ­¤æ—¶çš„ $siz[3]$ ä¸º $7$ï¼Œè€Œå¹¶éæ˜¯ $5$ ã€‚è¿™æ˜¯ç”±äºé€‰å®šçš„æ·±æœèŠ‚ç‚¹ä¸åŒï¼Œç»Ÿè®¡çš„ä¸åŒè€Œå¯¼è‡´çš„ã€‚$siz[3]$ çš„æ­£ç¡®å€¼ç†åº”æ¥è‡ªäºä» ç‚¹ $6$ å¼€å§‹æ·±æœçš„å€¼ã€‚ æ•…æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼Œç”¨ getroot(1,0) æ‰¾åˆ°æ•´æ£µæ ‘çš„é‡å¿ƒä¹‹åï¼Œå†æ¥ä¸€æ¬¡ getroot(root, 0)ï¼Œæ¥ç¡®å®šä»¥é‡å¿ƒä¸ºæ ¹ç»“ç‚¹æ—¶çš„ $siz$ æ•°ç»„ã€‚è¿™ä¸‹å°±å¯ä»¥ç›´æ¥ size = siz[v] äº†ã€‚\n11 1 6 7 1 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 2 ä¸è¦ç”¨ memset ç²—æš´è¿˜åŸï¼Œä¼šæµªè´¹å¾ˆå¤šæ—¶é—´ã€‚\nä¾‹äºŒ Luogu P4178 Treeï¼šç»™å®šä¸€æ£µæœ‰ $n$ ä¸ªç‚¹çš„å¸¦æƒæ ‘ï¼Œç»™å‡º $k$ï¼Œè¯¢é—®æ ‘ä¸Šè·ç¦»å°äºç­‰äº $k$ çš„ç‚¹å¯¹æ•°é‡ã€‚\n$n\\le 40000,k\\le 20000,w_i\\le 1000$\nè¿™é¢˜æ–¹æ³•æ¯”è¾ƒå¤šã€‚ä¸‹é¢çš„ä»£ç ç”¨ å®¹æ–¥ è¿›è¡Œå»é‡å’Œ åŒæŒ‡é’ˆ ï¼ˆé™¤æ­¤ä¹‹å¤–è¿˜å¯ä»¥ç”¨äºŒåˆ†ï¼‰ç»Ÿè®¡ç­”æ¡ˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int calc(int u, int w) { dis.clear(); getDis(u, -1, w); sort(dis.begin(), dis.end()); int sum = 0; int L = 0, R = dis.size() - 1; // åŒæŒ‡é’ˆ while (L \u0026lt; R) { if (dis[L] + dis[R] \u0026lt;= k) sum += R - L, L++; else R--; } return sum; } void solve(int u, int size) { centroid = 0; getCentroid(u, -1, size); getCentroid(centroid, -1, size); vis[centroid] = true; ans += calc(centroid, 0); for (auto i : g[centroid]) { if (vis[i.first]) continue; ans -= calc(i.first, i.second); // å®¹æ–¥ã€‚å»é™¤é”™è¯¯çš„ç­”æ¡ˆã€‚ } for (auto i : g[centroid]) { if (vis[i.first]) continue; solve(i.first, siz[i.first]); } } ä¾‹ä¸‰ æš‚ä¸”å’•å’•å’•ã€‚ğŸ•Š\nä¹ é¢˜ Luogu P4149 [IOI2011]Race Luogu P3714 [BJOI2017]æ ‘çš„éš¾é¢˜ Luogu P2634 [å›½å®¶é›†è®­é˜Ÿ]èªèªå¯å¯ å‚è€ƒèµ„æ–™ ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›ã€‹ OI Wiki ğŸ™‡â€\n","date":"August 2022","permalink":"https://blog.chungzh.cn/articles/centroid-decomposition/","tags":["OI","ç®—æ³•","æ•°æ®ç»“æ„","æ ‘çš„é‡å¿ƒ","ç‚¹åˆ†æ²»"],"title":"ç‚¹åˆ†æ²»ç¬”è®°"},{"categories":"çæå¼€å‘","contents":"ä¸Šä¸€æ¬¡æŠ˜è…¾åšå®¢å·²ç»æ˜¯ä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™çš„äº‹æƒ…äº†ã€‚ã€‚\nHugo è¿™ä¸ªæ¡†æ¶å¾ˆä¸é”™ï¼Œä¸æƒ³æ›´æ¢ï¼Œé‚£å°±å°è¯•åšä¸€ä¸ªä¸»é¢˜å§ã€‚\nHugo-klay è¿™ä¸ªåå­—å–è‡ªæˆ‘æœ€å–œæ¬¢çš„ NBA çƒå‘˜ Klay Thompsonï¼Œä¸ä¹…å‰ä»–éšé‡‘å·å‹‡å£«é˜Ÿå¤ºå¾—äº† 2021-2022 èµ›å­£çš„ NBA æ€»å† å†›ã€‚\nå®è¯è¯´ï¼Œæˆ‘çš„å‰ç«¯æ˜¯é›¶åŸºç¡€æ°´å¹³ï¼ŒJS å®Œå…¨ä¸ä¼šå†™ã€‚æ„Ÿè°¢éå¸¸å®¹æ˜“ä¸Šæ‰‹çš„ tailwindcss æ¡†æ¶ï¼ŒåŒæ—¶è¿˜å€Ÿï¼ˆæŠ„ï¼‰é‰´ï¼ˆè¢­ï¼‰äº†å¾ˆå¤š hugo-taniaã€hugo-theme-stack å’Œ hugo-tailwindcss-starter-theme çš„ä»£ç ã€‚\nå°±åƒå‰é¢è¯´çš„é‚£æ ·ï¼Œè¿™ä¸ªä¸»é¢˜çš„ä»£ç è´¨é‡æ¯”è¾ƒå·®ï¼Œè€Œä¸”ä¸»è¦ä¹Ÿæ˜¯è‡ªå·±ä½¿ç”¨ï¼Œæ‰€ä»¥æš‚æ—¶ä¸ä¼šå•ç‹¬ä¸ºè¿™ä¸ªä¸»é¢˜å¼€ä¸€ä¸ª repoã€‚å¦‚æœä½ æƒ³å‚è€ƒï¼Œä¹Ÿå¯ä»¥åˆ° ChungZH.github.io è¿™é‡Œå¯»æ‰¾æºç ã€‚æœ‰æ—¶é—´ çš„è¯ï¼Œæˆ‘ä¼šæ•´ç†ä¸€ä¸‹ä»£ç ï¼Œå†è€ƒè™‘å•ç‹¬åˆ†æˆä¸€ä¸ªé¡¹ç›®ã€‚\nè‡ªæˆ‘æ„Ÿè§‰è¿˜æ˜¯æŒºæ¼‚äº®çš„ï¼Œå“ˆå“ˆå“ˆã€‚\n","date":"July 2022","permalink":"https://blog.chungzh.cn/articles/hugo-klay/","tags":["Hugo","ä¸»é¢˜","blog","tailwind"],"title":"ç¬¬ä¸€æ¬¡åšä¸»é¢˜ï¼šhugo-klay"},{"categories":"å­¦ä¹ ç¬”è®°","contents":" å‰è¨€ å†™ä¸€é“ CF é¢˜çš„æ—¶å€™ï¼Œç®—æ³•æ˜æ˜æ˜¯æ­£ç¡®çš„ï¼Œå´ä¸€ç›´éƒ½ TLEã€‚æœ€åæŠŠä¸€ä¸ª long long ç±»å‹çš„æ•°ç»„æ”¹æˆäº† intï¼Œç«Ÿç„¶å°± AC äº†ã€‚ã€‚\nè¿™ä¸ç¦å¼•å‘äº†æˆ‘çš„æ€è€ƒï¼Œint ä¸ long long çš„è¿ç®—é€Ÿåº¦ä¸ä¸€æ ·å—ï¼Ÿ\nä¸ä¸¥è°¨æµ‹è¯• ç”±äºæœ¬èœé¸¡å¹¶æ²¡æœ‰ä»€ä¹ˆè®¡ç®—æœºåŸºç¡€åŸç†çš„çŸ¥è¯†ï¼Œåªå¥½åšäº†ä¸€ä¸ªæµ‹è¯•ã€‚å½“ç„¶ï¼Œè¿™ä¸ªæµ‹è¯•å…¶å®å¾ˆä¸ä¸¥è°¨ï¼Œæ²¡æœ‰å¾ˆå¤§çš„å‚è€ƒä»·å€¼ã€‚æˆ‘ä¹Ÿå°±å›¾ä¸€ä¹ï¼Œå“ˆå“ˆå“ˆå“ˆå“ˆ\næµ‹è¯•ç¯å¢ƒ ç”µè„‘ï¼šLenovo Yoga 14sACH 2021 ç³»ç»Ÿï¼šWindows 11 25163.1010 CPUï¼šAMD Ryzen 7 5800H with Radeon Graphics (16) @ 3.200GHz RAMï¼š16.0 GB ç¼–è¯‘å™¨ï¼šGCC 11.2.0 ä»£ç  ä»…ä»…æ˜¯ä¸ºäº†å›¾ä¸€ä¹ï¼Œ æˆ‘ç¬¬ä¸€æ¬¡ä½¿ç”¨äº† Google Benchmark è¿™ä¸€å·¥å…·ã€‚å…¶å®æŒºå¥½ä¸Šæ‰‹çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;benchmark/benchmark.h\u0026gt; using namespace benchmark; static void int_add(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) + (++b)); } static void ll_add(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) + (++b)); } static void int_div(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) / (++b)); } static void ll_div(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) / (++b)); } static void int_mod(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) % (++b)); } static void ll_mod(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) % (++b)); } BENCHMARK(int_add)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_add)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(int_div)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_div)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(int_mod)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_mod)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK_MAIN(); ç»“æœ 1 2 3 4 5 6 7 8 9 10 --------------------------------------------------------------------- Benchmark Time CPU --------------------------------------------------------------------- int_add/iterations:1000000000/threads:8 0.209 ns 1.57 ns ll_add/iterations:1000000000/threads:8 0.225 ns 1.71 ns int_div/iterations:1000000000/threads:8 0.302 ns 2.29 ns ll_div/iterations:1000000000/threads:8 0.306 ns 2.38 ns int_mod/iterations:1000000000/threads:8 0.345 ns 2.18 ns ll_mod/iterations:1000000000/threads:8 0.350 ns 2.34 ns ç»è¿‡å¤šæ¬¡æµ‹è¯•ï¼Œlong long ç±»å‹çš„å„ç§è¿ç®—éƒ½æ¯” int æ…¢ä¸€ç‚¹ã€‚\nStackOverflow é—®ç­” æ¯”è¾ƒä¸“ä¸šçš„ä¸€ä¸ªè§£ç­”ã€‚è¯¦è§ performance - C++ int vs long long in 64 bit machine - Stack Overflowã€‚\nè¿™é‡Œå¼•ç”¨ç›¸å…³é—®ç­”ï¼š\n1) If it is best practice to use long long in x64 for achieving maximum performance even for for 1-4 byte data?\nNo- and it will probably in fact make your performance worse. For example, if you use 64-bit integers where you could have gotten away with 32-bit integers then you have just doubled the amount of data that must be sent between the processor and memory and the memory is orders of magnitude slower. All of your caches and memory buses will crap out twice as fast.\nç»“è®º å¯ä»¥ä¸ç”¨ long long å°±å°½é‡ä¸ç”¨ã€‚æœ€å¥½ä¸è¦ä½¿ç”¨ #define int long long è¿™ç§ç²—æš´æ‰‹æ®µã€‚\nè‡´è°¢ï¼š\nC++ Benchmarking Tips for Beginners - Unum Blog ç¢ç¢å¿µï¼šçœŸçš„æœ‰å¤§åŠå¹´æ²¡å†™è¿‡åšå®¢äº†ï¼Œä¸Šæ¬¡æ›´æ–°è¿˜æ˜¯å¯’å‡å‘¢å“ˆå“ˆå“ˆã€‚ä¸€æ•´ä¸ªå­¦æœŸéƒ½å¥½å¿™å•Šï¼Œæ¥ä¸‹æ¥å°±æ˜¯åˆä¸‰äº†å‘¢ã€‚\nğŸ™‡\n","date":"July 2022","permalink":"https://blog.chungzh.cn/articles/int-vs-longlong/","tags":["C++","OI"],"title":"å…³äº int ä¸ long long çš„è¿ç®—é€Ÿåº¦"},{"categories":"å­¦ä¹ ç¬”è®°","contents":" Treap = Tree + Heap\näºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ åœ¨å­¦ä¹  Treap ä¹‹å‰ï¼Œéœ€è¦å…ˆäº†è§£ä¸€ä¸‹äºŒå‰æœç´¢æ ‘ï¼ˆBST, Binary Search Treeï¼‰ï¼š\nè®¾ $x$ æ˜¯äºŒå‰æœç´¢æ ‘ä¸­çš„ä¸€ä¸ªç»“ç‚¹ã€‚å¦‚æœ $y$ æ˜¯ $x$ å·¦å­æ ‘ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆ $y.key \\lt x.key$ã€‚å¦‚æœ $y$ æ˜¯ $x$ å³å­æ ‘ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆ $y.key \\gt x.key$ã€‚\nBST ä¸Šçš„åŸºæœ¬æ“ä½œæ‰€èŠ±è´¹çš„æ—¶é—´ä¸è¿™æ£µæ ‘çš„é«˜åº¦æˆæ­£æ¯”ã€‚å¯¹äºä¸€ä¸ªæœ‰ $n$ ä¸ªç»“ç‚¹çš„äºŒå‰æœç´¢æ ‘ä¸­ï¼Œè¿™äº›æ“ä½œçš„æœ€ä¼˜æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log n)$ï¼Œæœ€åä¸º $O(n)$ã€‚éšæœºæ„é€ è¿™æ ·ä¸€æ£µäºŒå‰æœç´¢æ ‘çš„æœŸæœ›é«˜åº¦ä¸º $O(\\log n)$ã€‚ç„¶è€Œï¼Œå½“è¿™æ£µæ ‘é€€åŒ–æˆé“¾æ—¶ï¼Œåˆ™åŒæ ·çš„æ“ä½œå°±è¦èŠ±è´¹ $O(n)$ çš„æœ€åè¿è¡Œæ—¶é—´ã€‚\nç”±äºæ™®é€š BST å®¹æ˜“é€€åŒ–ï¼Œå¯¹äºå®ƒçš„å®ç°å°±ä¸å†èµ˜è¿°ã€‚åœ¨å®è·µä¸­éœ€è¦ä½¿ç”¨å¦‚ Treap è¿™æ ·çš„å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚\nTreap é¡¾åæ€ä¹‰ï¼ŒTreap æ˜¯æ ‘å’Œå †çš„ç»“åˆã€‚å®ƒçš„æ•°æ®ç»“æ„æ—¢æ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œåˆæ˜¯ä¸€ä¸ªäºŒå‰å †ã€‚\nåœ¨ Treap çš„æ¯ä¸ªç»“ç‚¹ä¸­ï¼Œé™¤äº† $key$ å€¼ï¼Œè¿˜è¦ä¿å­˜ä¸€ä¸ª $fix$ï¼ˆæ›´å¸¸è§çš„æ˜¯ $priority$ï¼‰å€¼ã€‚è¿™ä¸ªå€¼æ˜¯éšæœºå€¼ï¼Œä»¥å®ƒä¸ºä¾æ®æ¥åŒæ—¶å»ºç«‹æœ€å¤§å †ï¼ˆæˆ–æœ€å°å †ï¼‰ã€‚å› ä¸º $fix$ å€¼æ˜¯éšæœºçš„ï¼Œæ‰€ä»¥å¯ä»¥è®©è¿™æ£µæ ‘æ›´åŠ å¹³è¡¡ï¼Œé«˜åº¦æ›´æ¥è¿‘ $O(\\log n)$ã€‚å®ƒçš„å„ç§æ“ä½œæœŸæœ›æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(\\log n)$ã€‚\næ—‹è½¬å¼ Treap æ—‹è½¬å¼ Treap çš„å¸¸æ•°è¾ƒå°ã€‚\næ—‹è½¬ å·¦æ—‹/å³æ—‹æ“ä½œä¸ä¼šç ´å BST çš„æ€§è´¨ï¼Œå¹¶å¯ä»¥é€šè¿‡å®ƒæ¥ç»´æŠ¤å †ï¼Œä½¿æ ‘å¹³è¡¡ã€‚\nå¦‚å›¾ï¼Œä»¥å³æ—‹ä¸ºä¾‹ã€‚å‡è®¾ç°åœ¨å·¦è¾¹æ ‘ $b$ çš„ $fix$ å€¼å¤§äº $a$ çš„ $fix$ å€¼ï¼Œç„¶è€Œ $b$ æ˜¯ $a$ çš„å„¿å­ï¼Œé‚£ä¹ˆå°±ä¸ç¬¦åˆæœ€å¤§å †çš„æ€§è´¨ï¼Œéœ€è¦è¿›è¡Œå³æ—‹ï¼Œå˜æˆäº†å³è¾¹çš„æ ‘ã€‚\nä½†æ˜¯ä¸ºä»€ä¹ˆåœ¨æ—‹è½¬çš„è¿‡ç¨‹ä¸­æ²¡æœ‰ç ´å BST çš„æ€§è´¨å‘¢ï¼Ÿè®¾ $c \\in C, d \\in D, e \\in E$ã€‚ç”±å·¦æ ‘çŸ¥ $c \\lt b \\lt d \\lt a \\lt e$ã€‚å†ç”±æ—‹è½¬ä¹‹åæ ‘çš„ç»“æ„å¯ä»¥å¾—å‡º $c \\lt b \\lt d \\lt a \\lt e$ï¼Œè¿™ä¸¤ä¸ªå¼å­æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥ï¼Œè¿™æ£µæ ‘ä¾ç„¶æ˜¯ BSTã€‚\nåœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œä¸­éƒ½è¦æŒ‰éœ€è¿›è¡Œæ—‹è½¬æ“ä½œã€‚\næ’å…¥ æ ¹æ® BST çš„æ€§è´¨ï¼Œæ‰¾åˆ°ç›¸åº”çš„ä½ç½®åˆ›å»ºæ–°å¶å­ç»“ç‚¹å°±å¯ä»¥äº†ã€‚å¦‚æœä¸ç¬¦åˆæœ€å¤§å †æ€§è´¨ï¼Œè¿›è¡Œæ—‹è½¬æ“ä½œã€‚\nåˆ é™¤ åˆ é™¤ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå¯ä»¥å¯¹è¢«åˆ é™¤çš„ç»“ç‚¹åˆ†ç±»è®¨è®ºï¼š\næ²¡æœ‰å­ç»“ç‚¹ï¼šç›´æ¥å°±æˆç©ºçš„äº† åªæœ‰ä¸€ä¸ªå­ç»“ç‚¹ï¼šæŠŠè¢«åˆ é™¤ç»“ç‚¹è®¾æˆå®ƒä»…æœ‰çš„å„¿å­å³å¯ æœ‰ä¸¤ä¸ªå­ç»“ç‚¹ï¼šé€‰å‡ºä¸¤ä¸ªå„¿å­ä¸­ $fix$ å€¼è¾ƒå¤§çš„ä¸€ä¸ªï¼Œé€šè¿‡æ—‹è½¬æ“ä½œæŠŠå®ƒè®¾æˆæ–°çš„æ ¹ï¼Œè¿™æ ·è¦åˆ é™¤çš„ç»“ç‚¹å°±åªæœ‰ä¸€ä¸ªå„¿å­äº†ï¼ŒæŒ‰ç…§æƒ…å†µ 2 å¤„ç†ã€‚è¿™ç§æ–¹æ³•ä¿è¯æ»¡è¶³äº† BST å’Œæœ€å¤§å †çš„æ€§è´¨ã€‚ åœ¨ç¨‹åºå®ç°æ—¶ï¼Œå®é™…ä¸Šæƒ…å†µ 1 å’Œ 2 çš„ä»£ç æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥åªç”¨åˆ†ä¸¤ç±»ã€‚\nä»¥ P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ - æ´›è°· ä¸ºä¾‹ï¼Œä»£ç å¦‚ä¸‹ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int INF = 1000000009; struct NODE { int val, fix, size; // size æŒ‡æ ‘çš„æ€»ç»“ç‚¹æ•° NODE *left, *right; NODE(const int val) : val(val) { fix = rand(); left = right = NULL; size = 1; } }; void maintain(NODE *\u0026amp;p) { p-\u0026gt;size = 1; if (p-\u0026gt;left != NULL) p-\u0026gt;size += p-\u0026gt;left-\u0026gt;size; if (p-\u0026gt;right != NULL) p-\u0026gt;size += p-\u0026gt;right-\u0026gt;size; } void rightRotate(NODE *\u0026amp;p) { NODE *tmp = p-\u0026gt;left; p-\u0026gt;left = tmp-\u0026gt;right; tmp-\u0026gt;right = p; p = tmp; maintain(tmp-\u0026gt;right); maintain(tmp); } void leftRotate(NODE *\u0026amp;p) { NODE *tmp = p-\u0026gt;right; p-\u0026gt;right = tmp-\u0026gt;left; tmp-\u0026gt;left = p; p = tmp; maintain(tmp-\u0026gt;left); maintain(tmp); } void insert(NODE *\u0026amp;p, const int value) { if (p == NULL) { p = new NODE(value); } else if (value \u0026lt;= p-\u0026gt;val) { insert(p-\u0026gt;left, value); if (p-\u0026gt;left-\u0026gt;fix \u0026lt; p-\u0026gt;fix) rightRotate(p); } else { insert(p-\u0026gt;right, value); if (p-\u0026gt;right-\u0026gt;fix \u0026lt; p-\u0026gt;fix) leftRotate(p); } maintain(p); } int count(const NODE *p, const int value) { if (!p) return 0; if (p-\u0026gt;val == value) return 1; if (value \u0026lt;= p-\u0026gt;val) return count(p-\u0026gt;left, value); return count(p-\u0026gt;right, value); } void remove(NODE *\u0026amp;p, const int value) { if (!p) return; if (p-\u0026gt;val == value) { if (p-\u0026gt;left == NULL || p-\u0026gt;right == NULL) { NODE *tmp = p; if (p-\u0026gt;right) p = p-\u0026gt;right; else p = p-\u0026gt;left; delete tmp; } else if (p-\u0026gt;left-\u0026gt;fix \u0026lt; p-\u0026gt;right-\u0026gt;fix) { rightRotate(p); remove(p-\u0026gt;right, value); maintain(p); } else { leftRotate(p); remove(p-\u0026gt;left, value); maintain(p); } } else if (value \u0026lt; p-\u0026gt;val) { remove(p-\u0026gt;left, value); maintain(p); } else { remove(p-\u0026gt;right, value); maintain(p); } } int getrank(const NODE *p, int value) { if (!p) return INF; int leftsize = 0; if (p-\u0026gt;left != NULL) leftsize = p-\u0026gt;left-\u0026gt;size; if (p-\u0026gt;val == value) return min(leftsize + 1, getrank(p-\u0026gt;left, value)); else if (value \u0026lt; p-\u0026gt;val) return getrank(p-\u0026gt;left, value); else if (value \u0026gt; p-\u0026gt;val) return leftsize + 1 + getrank(p-\u0026gt;right, value); } int find(const NODE *p, int rank) { if (!p) return 0; int leftsize = 0; if (p-\u0026gt;left != NULL) leftsize = p-\u0026gt;left-\u0026gt;size; if (leftsize \u0026gt;= rank) return find(p-\u0026gt;left, rank); else if (leftsize + 1 == rank) return p-\u0026gt;val; else return find(p-\u0026gt;right, rank - leftsize - 1); } int getpre(const NODE *p, int value) { // å‰é©± if (!p) return -INF; if (p-\u0026gt;val \u0026gt;= value) return getpre(p-\u0026gt;left, value); else return max(p-\u0026gt;val, getpre(p-\u0026gt;right, value)); } int getnext(const NODE *p, int value) { // åç»§ if (!p) return INF; if (p-\u0026gt;val \u0026lt;= value) return getnext(p-\u0026gt;right, value); else return min(p-\u0026gt;val, getnext(p-\u0026gt;left, value)); } int n; NODE *root; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n-- \u0026gt; 0) { int opt, x; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;opt, \u0026amp;x); if (opt == 1) { insert(root, x); } else if (opt == 2) { remove(root, x); } else if (opt == 3) { printf(\u0026#34;%d\\n\u0026#34;, getrank(root, x)); } else if (opt == 4) { printf(\u0026#34;%d\\n\u0026#34;, find(root, x)); } else if (opt == 5) { printf(\u0026#34;%d\\n\u0026#34;, getpre(root, x)); } else if (opt == 6) { printf(\u0026#34;%d\\n\u0026#34;, getnext(root, x)); } } return 0; } æ— æ—‹ Treap æ— æ—‹ Treap çš„æ ¸å¿ƒæ“ä½œæ˜¯åˆ†è£‚ã€åˆå¹¶ã€‚\nåˆ†è£‚ï¼ˆSplitï¼‰ åˆ†è£‚æ“ä½œä¼šå°†åŸ Treap ä¸€åˆ†ä¸ºäºŒï¼Œç¬¬ä¸€ä¸ª Treap ä¸­çš„ç»“ç‚¹å…³é”®å€¼éƒ½å°äºç­‰äº $key$ï¼Œç¬¬äºŒä¸ªä¸­éƒ½å¤§äº $key$ã€‚ä½¿ç”¨é€’å½’å®ç°ã€‚\nè‹¥å½“å‰å…³é”®å€¼å¤§äº $key$ï¼Œé‚£ä¹ˆå½“å‰ç»“ç‚¹è¿åŒå³å­æ ‘éƒ½å±äºç¬¬äºŒä¸ª Treapï¼Œç»§ç»­å¾€å·¦å­æ ‘é€’å½’ã€‚\nè‹¥å½“å‰å…³é”®å€¼å°äºç­‰äº $key$ï¼Œé‚£å½“å‰ç»“ç‚¹è¿åŒå·¦å­æ ‘éƒ½å±äºç¬¬ä¸€ä¸ª Treapã€‚ç»§ç»­å¾€å³å­æ ‘é€’å½’ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pair\u0026lt;NODE *, NODE *\u0026gt; split(NODE *u, const int value) { if (u == nullptr) return make_pair(nullptr, nullptr); if (u-\u0026gt;value \u0026gt; value) { auto tmp = split(u-\u0026gt;ch[0], value); u-\u0026gt;ch[0] = tmp.second; maintain(u); return make_pair(tmp.first, u); } else { auto tmp = split(u-\u0026gt;ch[1], value); u-\u0026gt;ch[1] = tmp.first; maintain(u); return make_pair(u, tmp.second); } } åˆå¹¶ï¼ˆMergeï¼‰ åˆå¹¶å‡½æ•°æ¥å—ä¸¤æ£µæ ‘ï¼Œå…¶ä¸­ç¬¬ä¸€æ£µçš„å€¼éƒ½å°äºç¬¬äºŒæ£µã€‚æ¯ä¸€æ¬¡æ ¹æ®ä¸¤æ£µæ ‘çš„æ ¹çš„ $fix$ å€¼æ¥ç¡®å®šæ–°æ ‘çš„æ ¹ï¼Œç„¶åé€’å½’åˆå¹¶å­æ ‘ã€‚\nå½“ä¸¤æ£µæ ‘ä»»ä½•ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œè¿”å›å¦ä¸€ä¸ªã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 NODE *merge(NODE *l, NODE *r) { if (l == nullptr) return r; if (r == nullptr) return l; if (l-\u0026gt;fix \u0026lt; r-\u0026gt;fix) { l-\u0026gt;ch[1] = merge(l-\u0026gt;ch[1], r); maintain(l); return l; } // else r-\u0026gt;ch[0] = merge(l, r-\u0026gt;ch[0]); maintain(r); return r; } æ’å…¥ å°†æ ‘åˆ†è£‚æˆä¸¤ä¸ªéƒ¨åˆ†ï¼š$A=\\lbrace x \\mid x \\le key \\rbrace$ã€$B= \\lbrace x \\mid x \\gt key \\rbrace$ï¼Œå…ˆå°†è¦æ’å…¥çš„å€¼åˆå¹¶å…¥ $A$ï¼Œæœ€ååˆå¹¶ $A$ å’Œ $B$ã€‚\n1 2 3 4 5 void insert(int value) { auto tmp = split(root, value); tmp.first = merge(tmp.first, new NODE(value)); root = merge(tmp.first, tmp.second); } åˆ é™¤ å°†æ ‘åˆ†è£‚æˆä¸‰ä¸ªéƒ¨åˆ†ï¼š$A= \\lbrace x \\mid x \\lt key \\rbrace$ã€$B= \\lbrace x \\mid x = key \\rbrace$ã€$C= \\lbrace x \\mid x \\gt key \\rbrace$ï¼Œç„¶ååˆå¹¶ $A$ å’Œ $C$ã€‚\n1 2 3 4 5 6 void erase(int value) { auto tmp = split(root, value - 1); auto tmp2 = split(tmp.second, value); delete tmp2.first; root = merge(tmp.first, tmp2.second); } è‡´è°¢ï¼š\nYWQ (Monad) OI Wiki CC BY-SA 4.0 ã€Šç®—æ³•å¯¼è®ºã€‹ Algorithms for Competitive Programming CC BY-SA 4.0 Treap - Wikipedia CC BY-SA 3.0 ","date":"February 2022","permalink":"https://blog.chungzh.cn/articles/treap/","tags":["OI","ç®—æ³•","æ•°æ®ç»“æ„","Treap"],"title":"Treap ç¬”è®°"},{"categories":"ç”Ÿæ´»","contents":"è¿™ä¸€å¹´è¿˜æ˜¯æ”¶è·æ»¡æ»¡çš„ã€‚\nOI ä¸ŠåŠå¹´å»äº† GDOI è§‚æ‘©ç¥ä»™æ‰“æ¶ï¼Œé•¿äº†è§è¯†ã€‚\nCSP-J 2021 1=ï¼ŒæŒºæ»¡æ„çš„ã€‚\nå¹´æœ«é•‡èµ›ç¬¬ä¸€ï¼Œè™½ç„¶è¯´æ²¡ä»€ä¹ˆç”¨ä½†æ˜¯å°±æ˜¯æŒºå¼€å¿ƒçš„ ğŸ˜\næ€»çš„æ¥è¯´ï¼Œè¿›æ­¥æŒºå¤§çš„ã€‚\nå­¦ä¹  æ˜¯çœŸæ­£çš„åˆä¸­ç”Ÿäº†ã€‚\nå‡ æ¬¡å¤§è€ƒï¼Œæœ‰æˆåŠŸï¼Œä¹Ÿæœ‰å¤±åˆ©ã€‚å¯ä»¥è¯´å¯¹äºå­¦ä¹ çš„å¿ƒæ€å˜æˆç†Ÿäº†ã€‚\nå€¼å¾—ä¸€æçš„æ˜¯ï¼Œåæœˆä»½çš„æ—¶å€™æ¢äº†ä¸€ä¸ªæ ¡é•¿ï¼Œå¸¦æ¥äº†å¾ˆå¤šæ–°æ°”è±¡ï¼Œå¹¸ç¦æ„Ÿä¸æ–­æå‡ã€‚æœŸå¾…ä»–åœ¨ä»¥åçš„è¡¨ç°ã€‚\nç”Ÿæ´» çˆ±ä¸Šäº† ğŸ“ ä¹’ä¹“çƒï¼Œä¹°äº†ä¸€ä¸ªäº”ç™¾å¤šçš„æ‹å­ï¼Œå¥¢ä¾ˆäº†ä¸€æŠŠï¼ŒçœŸçˆ½ï¼ˆ\nå¯¹è¿åŠ¨çš„çƒ­æƒ…é«˜æ¶¨äº†å¾ˆå¤šã€‚\næ€»ä¹‹ï¼Œå¸Œæœ›åœ¨æ–°çš„ä¸€å¹´ï¼Œä¸€åˆ‡éƒ½ä¼šæ›´å¥½ï¼\n","date":"December 2021","permalink":"https://blog.chungzh.cn/articles/goodbye2021/","tags":["æ€»ç»“"],"title":"å‘Šåˆ« 2021"},{"categories":"æ¸¸è®°","contents":" CSP-J/S è®¤è¯æ³¨æ„äº‹é¡¹ï¼š\n\u0026hellip;\u0026hellip;\n11. ç¥å„ä½é€‰æ‰‹å¥½è¿ã€‚\nCSP-J1 åˆèµ›å‰æœ‰ç‚¹å°ç´§å¼ ã€‚\nèµ›å‰å‹‰å¼ºåšäº†å‡ å¥—è¯•å·ï¼Œç„¶åå°±ä¸Šè€ƒåœºäº†ã€‚\nåˆšè€ƒå®Œå¯¹ç­”æ¡ˆçš„æ—¶å€™å‘ç° J ç»„æ‰ 72ï¼Œçœ‹æ´›è°·ä¸Šå¤§å®¶éƒ½è¯´ä»Šå¹´ J ç»„ç®€å•äº† blablaï¼Œåˆ†æ•°çº¿è‚¯å®šä¼šå‡ï¼Œç„¶è€Œæˆ‘å´è§‰å¾—å¥½éš¾ï¼Œé‚£ä¸€ä¸ªæ˜ŸæœŸéƒ½å®³æ€•æäº†ã€‚ã€‚ã€‚ç»“æœåˆ†æ•°å‡ºæ¥äº†æ‰å‘ç°æ´›è°·é‚£ç¾¤äººçœŸæ˜¯æ‰¯å•Šå“ˆå“ˆå“ˆ\nS ç»„æ‰ 48 åˆ†ï¼Œæ²¡æœ‰æˆåŠŸå‹çº¿ã€‚ï¼ˆå…¶å®å°±ç®—å»äº†å¤èµ›ä¹Ÿæ‹¿ä¸äº†åˆ†ã€‚ã€‚\nCSP-J2 æ¯”èµ›å‰ä¸€æ™šä¸Šå…«ç‚¹åœ¨å­¦æ ¡å‡ºå‘ã€‚é€ƒæ‰äº†æ™šè‡ªä¹ ï¼ˆå°½ç®¡æ˜¯æ˜ŸæœŸäº”\nå»åˆ°é…’åº—å¤§æ¦‚ä¹Ÿä¹ç‚¹åŠäº†ï¼Œæ´—å®Œæ¾¡ï¼Œçœ‹äº†ä¼šå„¿å‡¤å‡°å°ï¼Œç„¶åå°±ç¡äº†ã€‚\nç¬¬äºŒå¤©æ—©ä¸Šå…­ç‚¹åŠèµ·åºŠï¼Œåƒå®Œè‡ªåŠ©é¤ï¼ˆå’Œä¸Šä¸€å¹´çš„å˜åŒ–ä¸å¤§ï¼ŒæŒºå¥½åƒçš„ï¼‰ï¼Œä¸ƒç‚¹äºŒåå‡ºå‘ã€‚\nç„¶åè¿›è€ƒåœºã€‚\nç”µè„‘å¥½åƒæ˜¯ Ryzen 3600ï¼Œ8GB å†…å­˜ã€‚\nå…«ç‚¹åŠå¼€è€ƒã€‚\nå¯†ç å¾ˆä¹±ï¼Œ6ewid\\n16384#ï¼Œç›‘è€ƒå‘˜ä¸€å¼€å§‹è¿˜ç›´æ¥å¿½ç•¥æœ€åé¢é‚£ä¸ªäº•å·äº†ã€‚ã€‚ã€‚\næ‰“å¼€é¢˜ç›®ï¼Œå‘ç°ç¬¬ä¸€ç¬¬äºŒé¢˜é¢˜é¢å¥½é•¿ï¼Œæœ‰ç‚¹æ…Œäº†èµ·æ¥\u0026hellip;\nT2 å°¤ä¸ºæ¯’ç˜¤ï¼Œåˆ°äº† 9:22 æ‰æå®Œäº†ã€‚ã€‚ã€‚æ„Ÿè§‰æŒºå¾ˆå±é™©çš„ï¼Œå¥½æ€•ç¿»è½¦ã€‚\n10:08ï¼Œè‚å®Œ T3ï¼Œ77 è¡Œä»£ç ï¼Œå†™å®Œäººéƒ½ç˜«äº†ã€‚ã€‚æ„Ÿè°¢ç¬¬ä¸‰ä¸ªæ ·ä¾‹ï¼Œä¸€ä¸ªä¸€ä¸ªæ‰¾æƒ…å†µã€‚ã€‚ã€‚\nï¼ˆä¸çŸ¥é“æ€ä¹ˆæ¯”å¯¹ä¸¤ä¸ªæ–‡ä»¶çš„å†…å®¹ï¼Œäºæ˜¯ç›´æ¥æ‰“å¼€ Sublime Text å¼€å§‹ç”¨æŸ¥æ‰¾æ¥æ‰¾ä¸åŒã€‚ã€‚ã€‚\nèµ¶ç´§åƒäº†æ ¹å£«åŠ›æ¶ï¼Œç„¶åå»ä¸Šäº†ä¸ªå•æ‰€ã€‚\n10:55ï¼ŒT4 è¿‡æ ·ä¾‹äº†ï¼Œæ‰“å¾—æ¯” T3 è½»æ¾å¤šäº†ï¼Œå½“ç„¶ä¹Ÿä¸å¯èƒ½æ‹¿æ»¡åˆ†ã€‚ã€‚ã€‚å…¶å®ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼Œç›´æ¥ä¹±æï¼Œåšæ³•éå¸¸è¯¡å¼‚ã€‚ã€‚çœ‹çœ‹æ•ˆæœæ€æ ·å§ï¼Œèƒ½éª—åˆ° 50 åˆ†å°±æ˜¯èƒœåˆ©ã€‚\nè¿˜æœ‰ä¸€ç‚¹ï¼Œä»Šå¹´ NOI Linux 2 è¿˜è¡Œã€‚ï¼ˆæ¯•ç«Ÿä¸Šä¸€å¹´ç»™äº†è™šæ‹Ÿæœºä½†æ˜¯ç³»ç»Ÿæœ‰å¯†ç ï¼Œæ ¹æœ¬æ‰“ä¸å¼€ï¼Œç¬‘æ­»ï¼‰åœ¨é‡Œé¢ç¼–è¯‘äº†å‡ æ¬¡ä»£ç ï¼Œè™½ç„¶ä¹Ÿæ²¡ä»€ä¹ˆç”¨ã€‚è¿è¡Œèµ·æ¥è¿˜è›®å¿«çš„ã€‚\næ€»çš„æ¥è¯´ï¼Œè¿™æ¬¡è€ƒå¾—è¿˜è¡Œã€‚é¢˜ç›®æœ‰ç‚¹è¯¡å¼‚ï¼Œæ²¡æœ‰ dpï¼Œæ²¡æœ‰æœç´¢ï¼Œä¸ªäººæ„Ÿè§‰ä¾§é‡è€ƒåŸºæœ¬åŠŸã€‚\nç­‰æˆç»©å§ã€‚\nUPD 1 (2021/10/23 22:50)ï¼š\nå¹¿ä¸œæºä»£ç å‡ºäº†ã€‚\ncandy: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long n, L, R; int main() { freopen(\u0026#34;candy.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;candy.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; long long LRCHA = (R-L+1); long long LCN = L/n, RCN = R/n; if (RCN \u0026gt; LCN) { cout \u0026lt;\u0026lt; n-1 \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; R-LCN*n \u0026lt;\u0026lt; endl; return 0; } sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, Q; long long a[8005]; int idxa[8005]; bool cmp(int i1, int i2) { if (a[i1] != a[i2]) return a[i1] \u0026lt; a[i2]; return i1 \u0026lt; i2; } int main() { freopen(\u0026#34;sort.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;sort.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;Q); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); while (Q--) { int type; scanf(\u0026#34;%d\u0026#34;, \u0026amp;type); if (type == 1) { // ï¿½Ş¸ï¿½ int x; long long v; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;x, \u0026amp;v); a[x] = v; for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); } else if (type == 2) { // ï¿½ï¿½Ñ¯ int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int i = 1; i \u0026lt;= n; i++) { if (idxa[i] == x) { printf(\u0026#34;%d\\n\u0026#34;, i); break; } } } } return 0; } network: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; bool checkPrevZero(const string number) { if (number.length() \u0026gt; 1 \u0026amp;\u0026amp; number[0] == \u0026#39;0\u0026#39;) return true; return false; } int strToInt(const string number) { int t = 0; for (int i = 0; i \u0026lt; number.length(); i++) { t *= 10; t += number[i]-\u0026#39;0\u0026#39;; } return t; } bool check(const string addr) { int cntDot = 0, cntMao = 0; int dotIdx[3], maoIdx;\tif (!(addr[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[0] \u0026lt;= \u0026#39;9\u0026#39;) || !(addr[addr.length()-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[addr.length()-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; for (int i = 0; i \u0026lt; addr.length(); i++) { if (addr[i] == \u0026#39;.\u0026#39;) { if (cntDot \u0026gt; 2) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntDot++; dotIdx[cntDot-1] = i; } else if (addr[i] == \u0026#39;:\u0026#39;) { if (cntMao \u0026gt; 1) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntMao++; maoIdx = i; } else if (!(addr[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i] \u0026lt;= \u0026#39;9\u0026#39;)) { return false; } } if (!(cntDot == 3 \u0026amp;\u0026amp; cntMao == 1)) return false; if (maoIdx \u0026lt; dotIdx[2]) return false; string n1 = addr.substr(0, dotIdx[0]), n2 = addr.substr(dotIdx[0]+1, dotIdx[1]-dotIdx[0]-1), n3 = addr.substr(dotIdx[1]+1, dotIdx[2]-dotIdx[1]-1), n4 = addr.substr(dotIdx[2]+1, maoIdx-dotIdx[2]-1), n5 = addr.substr(maoIdx+1, addr.length()-maoIdx-1); //cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n4 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n5 \u0026lt;\u0026lt; endl; if (checkPrevZero(n1) || checkPrevZero(n2) || checkPrevZero(n3) || checkPrevZero(n4) || checkPrevZero(n5)) return false; if (n1.length() \u0026gt; 3 || n2.length() \u0026gt; 3 || n3.length() \u0026gt; 3 || n4.length() \u0026gt; 3 || n5.length() \u0026gt; 5) return false; int a = strToInt(n1), b = strToInt(n2), c = strToInt(n3), d = strToInt(n4), e = strToInt(n5); if (a \u0026gt; 255 || b \u0026gt; 255 || c \u0026gt; 255 || d \u0026gt; 255 || e \u0026gt; 65535) return false; return true; } int serversNum = 0; map\u0026lt;string, int\u0026gt; servers; int main() { freopen(\u0026#34;network.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;network.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n; string op, ad; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; ad; if (!check(ad)) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } if (op == \u0026#34;Server\u0026#34;) { if (servers[ad] != 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } servers[ad] = i+1; cout \u0026lt;\u0026lt; \u0026#34;OK\\n\u0026#34;; } else if (op == \u0026#34;Client\u0026#34;) { if (servers[ad] == 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } cout \u0026lt;\u0026lt; servers[ad] \u0026lt;\u0026lt; endl; } } return 0; } fruit: ï¼ˆä»£ç éå¸¸å¥‡å¦™ï¼Œæ€è·¯ååˆ†æ— ç†ï¼Œå»ºè®®ä¸è¦çœ‹ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct node { int idx; int val; int ai; int len; }; int n; int a[200005]; vector\u0026lt;node\u0026gt; sons[405005]; int nodeNums = 1; void buildtree(int root, int left, int right, bool rrr) { if (rrr) { int prev = 1; for (int i = 2; i \u0026lt;= n; i++) { if (a[i] != a[prev]) { sons[1].push_back({nodeNums+1, a[prev], prev, i-prev}); buildtree(nodeNums+1, prev, i-1, 0); nodeNums++; prev = i; } } sons[1].push_back({nodeNums+1, a[prev], prev, n-prev+1}); buildtree(nodeNums+1, prev, n, 0); nodeNums++; } else { for (int i = left; i \u0026lt;= right; i++) { sons[root].push_back({++nodeNums, a[left], i, 1}); } } } void work() { for (int i = 0; i \u0026lt; sons[1].size(); i++) { printf(\u0026#34;%d \u0026#34;, sons[sons[1][i].idx][0].ai); sons[sons[1][i].idx].erase(sons[sons[1][i].idx].begin()); if (sons[sons[1][i].idx].size() == 0) { sons[1].erase(sons[1].begin()+i); i--; } } // merge for (int i = 1; i \u0026lt; sons[1].size(); i++) { if (sons[1][i].val != sons[1][i-1].val) continue; int id = sons[1][i].idx; for (int j = 0; j \u0026lt; sons[id].size(); j++) { sons[sons[1][i-1].idx].push_back(sons[id][j]); } sons[1].erase(sons[1].begin()+i); i--; } printf(\u0026#34;\\n\u0026#34;); } int main() { freopen(\u0026#34;fruit.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;fruit.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } buildtree(1, 1, n, 1); while (sons[1].size()) { work(); } return 0; } æ´›è°·è‡ªæµ‹ï¼š342 = 100 + 72 + 100 + 70\nè®¡è’œå®¢è‡ªæµ‹ï¼š342 = 100 + 52 + 100 + 90\nç›®å‰çœ‹ä¸Šå» 1= ç¨³äº†ã€‚\nUPD 2 (2021/10/30 22:38)ï¼š\nCCF å®˜æ–¹ï¼š100 + 52 + 100 + 70 = 322\n","date":"October 2021","permalink":"https://blog.chungzh.cn/articles/csp2021/","tags":["æ¸¸è®°","OI","CSP"],"title":"CSP-J 2021 æ¸¸è®°"},{"categories":"å­¦ä¹ ç¬”è®°","contents":"çº¿æ®µæ ‘æ˜¯ä¸€ç§é«˜ç«¯çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨æ¥åœ¨åŒºé—´ä¸Šè¿›è¡Œä¿¡æ¯ç»Ÿè®¡ã€‚å®ƒèƒ½å¤Ÿåœ¨ $O(logN)$ çš„æ—¶é—´å¤æ‚åº¦å†…å®ç°å•ç‚¹/åŒºé—´ä¿®æ”¹ã€åŒºé—´æ‰¾æœ€å¤§å€¼/æœ€å°å€¼/æ€»å’Œ/\u0026hellip;ï¼Œé€‚ç”¨äºå¤§è§„æ¨¡çš„åŒºé—´ç»Ÿè®¡ã€‚\nå¦‚ä¸‹å›¾å°±æ˜¯ä¸€æ£µçº¿æ®µæ ‘ã€‚åœ¨ç»“ç‚¹ä¸­ï¼Œä½ å¯ä»¥å­˜å¯¹åº”åŒºé—´çš„æœ€å¤§å€¼ï¼Œæœ€å°å€¼ï¼Œæ€»å’Œç­‰ç­‰ã€‚\nå¯¹äºæ¯ä¸€ä¸ªç»“ç‚¹ $i$ï¼Œå®ƒçš„ä¸¤ä¸ªå­ç»“ç‚¹åˆ†åˆ«æ˜¯ $2i$ å’Œ $2i+1$ã€‚å› æ­¤ï¼Œåœ¨å¼€æ ‘çš„æ•°ç»„æ—¶ï¼Œæœ€å¥½è¦å¼€åˆ° $4N$ çš„å¤§å°ã€‚\nå…³äº $4N$ï¼Œè¯¦è§ OI-Wikiã€‚\nå»ºæ ‘ ä¸‹é¢æ˜¯ä¸€ä¸ªæ±‚åŒºé—´å’Œçš„çº¿æ®µæ ‘çš„å»ºæ ‘ä»£ç ã€‚\né€šè¿‡ DFS å»ºæ ‘ï¼Œåˆ°å¶ç»“ç‚¹ï¼Œç„¶åä¸€è·¯å›æº¯æ±‚å‡ºå’Œã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 void build_tree(int cur, int left, int right) { // cur ä¸ºå½“å‰æ ‘çš„æ ¹ï¼Œ[left, right] æ˜¯å½“å‰æ ‘å¯¹åº”çš„åŒºé—´ if (left == right) { // åˆ°å¶å­èŠ‚ç‚¹äº†ï¼ŒåŒºé—´é•¿åº¦ä¸º 1ï¼Œæ€»å’Œå°±æ˜¯å®ƒæœ¬èº« tree[cur] = a[left]; return ; } int leftSon = cur*2, rightSon = leftSon+1; int mid = (left+right)/2; build_tree(leftSon, left, mid); build_tree(rightSon, mid+1, right); tree[cur] = tree[leftSon]+tree[rightSon]; // æ±‚å’Œ } è¿™é‡Œæ±‚ leftSonï¼ŒrightSonï¼Œmid çš„æ¨¡å¼åœ¨çº¿æ®µæ ‘çš„æ‰€æœ‰æ“ä½œä¸­éƒ½ä¼šç”¨åˆ°ã€‚\nåŒºé—´æŸ¥è¯¢ å¯¹äºä¸€ä¸ªä¸æ°å¥½çš„åŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥ä¸æ–­åœ°æŠŠå®ƒæ‹†åˆ†æˆä¸¤ä¸ªæ°å¥½çš„åŒºé—´å†è¿›è¡Œåˆå¹¶ã€‚\nå¦‚å›¾æ‰€ç¤ºï¼Œæ‹†åˆ†è¿‡ç¨‹å¦‚ä¸‹ï¼š\n[3, 7] [3, 4], [5, 7] [3, 4], [5, 6], [7, 7] åœ¨å®é™… DFS è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼š\nå½“å‰ç»“ç‚¹å¯¹åº”åŒºé—´å’Œè¦æŸ¥è¯¢çš„åŒºé—´å®Œå…¨æ— å…³ï¼Œç›´æ¥é€€å‡º å½“å‰ç»“ç‚¹å¯¹åº”åŒºé—´å®Œå…¨å¤„äºè¦æŸ¥è¯¢çš„åŒºé—´èŒƒå›´ï¼Œè¿”å›å½“å‰ç»“ç‚¹çš„å€¼ ä¸¤ä¸ªåŒºé—´éƒ¨åˆ†ç›¸äº¤ï¼Œç»§ç»­æ‹†åˆ†ä¸º 1 æˆ– 2 æƒ…å†µ 1 2 3 4 5 6 7 8 9 long long query(int cur, int l, int r, int x, int y) { // cur ä¸ºå½“å‰æ ‘çš„æ ¹ï¼Œ[l, r] æ˜¯å½“å‰æ ‘å¯¹åº”çš„åŒºé—´ï¼Œ[x, y] æ˜¯è¦æŸ¥è¯¢çš„åŒºé—´ if (y \u0026lt; l || r \u0026lt; x) return 0; // 1. ç›¸ç¦» if (x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) return tree[cur]; // 2. å®Œå…¨åŒ…å« // 3. ç›¸äº¤ int leftSon = cur*2, rightSon = leftSon+1; int mid = (l+r)/2; return query(leftSon, l, mid, x, y) + query(rightSon, mid+1, r, x, y); // æ±‚å’Œ } åŒºé—´ä¿®æ”¹ å•ç‚¹ä¿®æ”¹å¹¶æ²¡æœ‰ä»€ä¹ˆæ„æ€ï¼Œå°±ä¸è®²äº†ã€‚\nåŒºé—´ä¿®æ”¹å½“ç„¶ä¸æ˜¯é‡å¤åšå•ç‚¹ä¿®æ”¹ï¼Œå¦åˆ™ä½¿ç”¨çº¿æ®µæ ‘å°±å¾ˆæ²¡æœ‰å¿…è¦äº†ã€‚ä¸ºäº†é¿å…èµ°åˆ°åº•ä¸‹å»ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨ä¸€ä¸ªæ‡’æƒ°æ ‡è®°ï¼ˆlazy tagï¼‰ã€‚å½“ä¸€ä¸ªå¤§åŒºé—´å†…æ‰€æœ‰çš„å°å•ä½éƒ½è¦è¿›è¡ŒåŒæ ·çš„ä¿®æ”¹æ“ä½œæ—¶ï¼Œåªéœ€è¦åœ¨å¤§åŒºé—´åšä¸€æ¬¡æ ‡è®°å°±å¯ä»¥äº†ã€‚åˆ°äº†å¿…é¡»è¦èµ°ä¸‹å»ï¼ˆå³æŸ¥è¯¢æ›´å°çš„åŒºé—´æˆ–ä¿®æ”¹æ›´å°çš„åŒºé—´ï¼‰çš„æ—¶å€™ï¼Œå†æŠŠæ‡’æƒ°æ ‡è®°ä¸‹æ”¾ã€‚\nä¸‹é¢ä»¥ä¸€ä¸ªåŒºé—´å¢åŠ ä¸€ä¸ªå€¼å¹¶è¿›è¡ŒåŒºé—´æŸ¥è¯¢ä¸ºä¾‹ã€‚\né¦–å…ˆå®šä¹‰ä¸€ä¸ªç»“æ„ä½“ï¼Œå…¶ä¸­ add å°±æ˜¯è®°å½•è¿™ä¸ªåŒºé—´éœ€è¦å¢åŠ çš„å€¼ã€‚\n1 2 3 4 struct node { long long sum, add; } tree[4 * MAXN]; ä¸‹æ”¾æ“ä½œï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 void pushdown(int cur, int left, int mid, int right) { // å°†å½“å‰ç»“ç‚¹çš„ add å€¼ä¸‹æ”¾ç»™å­ç»“ç‚¹ const int leftSon = cur * 2, rightSon = leftSon + 1; // æ›´æ–°æ€»å’Œï¼ˆåŒºé—´å…ƒç´ ä¸ªæ•°*æ¯ä¸ªå…ƒç´ è¦å¢åŠ çš„å€¼ï¼‰ tree[leftSon].sum += (mid - left + 1) * tree[cur].add; tree[rightSon].sum += (right - mid) * tree[cur].add; // æ›´æ–° add å€¼ tree[leftSon].add += tree[cur].add; tree[rightSon].add += tree[cur].add; // å½“å‰ç»“ç‚¹çš„æ‡’æƒ°æ ‡è®°å·²ç»ä¸‹æ”¾ï¼Œéœ€è¦æ¸…é›¶ tree[cur].add = 0; } åŒºé—´å¢åŠ ä¸€ä¸ªå€¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void update(int cur, int left, int right, int x, int y, ll c) { if (left \u0026gt; y || right \u0026lt; x) // ç›¸ç¦» return; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // å®Œå…¨åŒ…å« { // ç»™å½“å‰åŒºé—´æ•´ä½“å¢åŠ  c tree[cur].sum += (right - left + 1) * c; // æ‰“æ ‡è®° tree[cur].add += c; // è¿™æ—¶ä¸éœ€è¦å­ç»“ç‚¹çš„å€¼ï¼Œæ‰€ä»¥ä¸å¿…ä¸‹æ”¾ return; } // ç›¸äº¤ // åˆ†æˆä¸¤ä¸ªå­åŒºé—´ï¼Œå¿…é¡»è¦å¾€ä¸‹èµ°äº† int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // å…ˆä¸‹æ”¾æ ‡è®° update(leftSon, left, mid, x, y, c); update(rightSon, mid + 1, right, x, y, c); tree[cur].sum = tree[2 * cur].sum + tree[2 * cur + 1].sum; // æœ€åæ±‡æ€»æ€»å’Œ } åŒºé—´æŸ¥è¯¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 ll query(int cur, int left, int right, int x, int y) { if (left \u0026gt; y || right \u0026lt; x) // ç›¸ç¦» return 0; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // å®Œå…¨åŒ…å« return tree[cur].sum; // ç›¸äº¤ // æ‹†æˆä¸¤ä¸ªå­—åŒºé—´å†æ±‚å’Œ int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // å¿…é¡»å¾€ä¸‹èµ°ï¼Œä¸‹æ”¾æ ‡è®° return query(leftSon, left, mid, x, y) + query(rightSon, mid + 1, right, x, y); } é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼šæ‡’æƒ°æ ‡è®°å°±æ˜¯ä¸ºäº†ä¸å¾€ä¸‹èµ°ï¼Œå°½é‡åœ¨æ›´å¤§çš„åŒºé—´åšä¸€æ¬¡æ“ä½œã€‚å¿…è¦æ—¶æ‰å¾€ä¸‹ä¸‹æ”¾æ ‡è®°ã€‚å®ƒä¸ä¼šä¸»åŠ¨åšäº‹ï¼Œè€Œæ˜¯åˆ°ä½ éœ€è¦çš„æ—¶å€™æ‰èŠ±æ—¶é—´å»åšã€‚é€šè¿‡è¿™æ ·èŠ‚çœäº†å¾ˆå¤šæ—¶é—´ã€‚\nå°ç»“ æ€»çš„æ¥è¯´ï¼Œçº¿æ®µæ ‘ä¸æ˜¯ä¸€ä¸ªå¾ˆéš¾çš„æ•°æ®ç»“æ„ï¼Œä½†æ˜¯å¾ˆå®ç”¨ã€‚\næ„Ÿè°¢ lgj è€å¸ˆï¼\n","date":"August 2021","permalink":"https://blog.chungzh.cn/articles/segment-tree/","tags":["OI","ç®—æ³•","æ•°æ®ç»“æ„","çº¿æ®µæ ‘"],"title":"çº¿æ®µæ ‘ç¬”è®°"},{"categories":"çæå¼€å‘","contents":"æš‘å‡æ¥äº†ï¼Œé¡ºä¾¿æŠŠåšå®¢æ›´æ–°ä¸€ä¸‹ã€‚\nä»ä»¥å‰çš„ Vuepress å˜æˆäº† Hugoï¼Œé€Ÿåº¦çœŸçš„å¿«äº†å¾ˆå¤šï¼Œä¸æ„§æ˜¯ \u0026ldquo;The worldâ€™s fastest\u0026rdquo;ã€‚ç”¨çš„ä¸»é¢˜æ˜¯ Taniaï¼Œå¾ˆç®€æ´ã€æ¼‚äº®ã€‚Hugo éå¸¸æ˜“ç”¨ï¼Œä¸åˆ°åŠå¤©å°±å®Œæ•´è¿ç§»è¿‡æ¥äº†ã€‚æˆ‘å¯ä»¥å¾ˆè‚¯å®šåœ°è¯´è¿™ä¸€æ¬¡åšå®¢è¿ç§»æ˜¯æœ‰å²ä»¥æ¥æœ€å¿«çš„ä¸€æ¬¡ã€‚\nCI ç”¨çš„æ˜¯ GitHub Actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: github pages on: push: branches: - hugo # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: master # default: gh-pages æ€»ä¹‹å°±æ˜¯éå¸¸ä¸æ»‘ï¼ŒHugo NB!\n","date":"July 2021","permalink":"https://blog.chungzh.cn/articles/hello-hugo/","tags":["Blog","Hugo"],"title":"Hello Hugo!"},{"categories":"æ¸¸è®°","contents":" ä»–å±±ä¹‹çŸ³ï¼Œå¯ä»¥æ”»ç‰ã€‚\nCSP-J1 å…¥å­¦ä½ æ ¡å‡ ä¹ä¸¤ä¸ªæœˆéƒ½åœ¨æåˆèµ›ã€‚\nç»“æœåˆä¸€è¿˜æ˜¯åªæœ‰ä¸¤ä¸ªäººè¿‡äº†\næœ€åæ˜¯ 73.5 åˆ†ï¼Œæ°´è¿‡å»äº†ã€‚\nCSP-J2 Day 0 è¦å»å¤§å­¦åŸçš„å¹¿å¤§é™„ä¸­ï¼Œå°±å»ä½é…’åº—äº†ã€‚\nåœ¨ tjl å¤§ä½¬æˆ¿é—´é‡Œ ç©ï¼Œå…¶å®æ˜¯åœ¨çœ‹å‡¤å‡°å°ã€‚\nä¾ç¨€è®°å¾—é‚£æ™šä¸Šæ‹œç™»å’Œç‰¹æœ—æ™®çš„æ¯”åˆ†æ˜¯ 264 : 214ï¼Œæ—éƒ‘å»åŒ—äº¬è§éŸ©æ­£äº†ã€‚\nCCTV-7 ä¸Šé¢ä¸­ç§‘é™¢åœ¨å¸®å†œæ°‘ç§æ©˜å­ï¼Ÿ\nåç‚¹å¤šå°±å›å»æ˜æ˜æ²‰æ²‰åœ°ç¡äº†ï¼Œè¿˜æŒºé¦™ï¼ˆ\nDay 1 æ—©ä¸Šå…­ç‚¹åŠå°±é†’äº†ã€‚\nåœ¨é…’åº—åƒäº†é¡¿è‡ªåŠ©æ—©é¤ï¼ŒçœŸé¦™ã€‚\nåˆ°å¤„éƒ½æ˜¯çŸ³å®çš„å¤§ä½¬ %%% ã€‚\nç„¶åæ­ç€åŒæ ¡çƒ­å¿ƒå®¶é•¿çš„è½¦å‰å¾€å¹¿å¤§é™„ä¸­ã€‚\né—¨å£è¿˜æŒºçƒ­é—¹çš„ï¼Œå¥½åƒå‘ç”Ÿäº†è®¸å¤šäº‹æƒ…ï¼š\né»„è€å¸ˆèº«ä»½è¯ä¸è§äº†ï¼Œå…¶å®è—åœ¨è¢‹å­é‡Œ æŸå¤§ä½¬æ²¡å¸¦å‡†è€ƒè¯ è¿˜æœ‰æ²¡å¸¦ç²¤åº·ç çš„ äºæ˜¯æ„Ÿåˆ°å¾ˆåº†å¹¸ï¼Œæ²¡å…¥è€ƒåœºçš„æ—¶å€™ä¹Ÿæ˜¯ä¸€åœºè€ƒéªŒã€‚ã€‚æ‰€ä»¥è¯´å¸¦é½èµ„æ–™å¾ˆé‡è¦ã€‚\nå¾ˆå¿«å°±è¿›è€ƒåœºäº†ã€‚\nç”µè„‘æœ‰ 8G å†…å­˜ï¼Œè£…çš„æ˜¯ Windows 10 ç¥å·ç½‘ä¿¡æ”¿åºœç‰ˆï¼Œæ„Ÿè§‰åªæ˜¯å¼€å§‹èœå•çœ‹ä¸Šå»ç¨æœ‰ä¸åŒã€‚\nä¸‹å‘é¢˜ç›®ä¹‹åå‡ åˆ†é’Ÿæˆ‘è¿˜åœ¨æ‰“ A+Bï¼Œæ‰“å®Œä¹‹åæ‰ä¸€æ„£ä¸€æ„£åœ°æŠ„å¯†ç è§£å‹é¢˜ç›®ã€‚\nç¿»äº†ä¸€ä¸‹ï¼Œå‘ç°ç¬¬ä¸€é¢˜å¥½éš¾ï¼Œäºæ˜¯ä»ç¬¬äºŒé¢˜å¼€å§‹åšã€‚\nT2 åˆšå¼€å§‹ç«Ÿç„¶ç”¨äº† sortï¼Œåˆ°äº†æœ€åè¯•å¤§æ ·ä¾‹çš„æ—¶å€™æ‰çœ‹åˆ°ä¸€å¡ä¸€å¡çš„ï¼Œäºæ˜¯åˆæ”¹æˆäº†æ’å…¥æ’åºï¼Œä»¥ä¸ºæ²¡é—®é¢˜äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool cmp(int a, int b) { return a \u0026gt; b; } int a[100005]; int main() { int n, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); for (int i = 0; i \u0026lt; n; i++) { int inp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;inp); int j = 0; for (; j \u0026lt; i; j++) { if (a[j] \u0026lt; inp) break; } for (int k = i; k \u0026gt;= j; k--) { a[k+1] = a[k]; } a[j] = inp; int planNum = max(1, (int)((i+1)*0.01*w)); printf(\u0026#34;%d \u0026#34;, a[planNum-1]); } return 0; } ç„¶å T3 çœ‹äº†å¥½ä¹…æ‰å¼„æ‡‚ï¼Œå°±æš´åŠ› stack äº†ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int n; int a[100003]; int main() { string expr; getline(cin, expr); const int exprlen = expr.length(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; q; i++) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); a[t] = !a[t]; string cur; for (int j = 0; j \u0026lt; exprlen+1; j++) { if (j == exprlen || expr[j] == \u0026#39; \u0026#39;) { if (cur == \u0026#34;!\u0026#34;) { int t = s.top(); s.pop(); s.push(!t); } else if (cur == \u0026#34;\u0026amp;\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t \u0026amp;\u0026amp; t2); } else if (cur == \u0026#34;|\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t || t2); } else if (cur[0] == \u0026#39;x\u0026#39;) { int xb = 0; for (int k = 1; k \u0026lt; cur.length(); k++) { xb *= 10; xb += cur[k]-\u0026#39;0\u0026#39;; } s.push(a[xb]); } cur.clear(); } else cur += expr[j]; } printf(\u0026#34;%d\\n\u0026#34;, s.top()); if (!s.empty()) s.pop(); a[t] = !a[t]; } return 0; } æ¥ä¸‹æ¥æ‰å¼€å§‹æ„æ€ç¬¬ä¸€é¢˜ï¼Œä¸€ç›´æ‘¸ä¸ç€å¤´ç»ªï¼Œå°±éšéšä¾¿ä¾¿å†™äº†ä¸€ä¸ªçˆ†æœï¼Œæšä¸¾ 2 çš„å¹‚ç›¸åŠ ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; const int a[23] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608}; int ansn = 0, ans[24]; int dfs(int step, int sum) { if (sum \u0026gt; n) return 0; if (step \u0026gt; 23) return 0; if (sum == n) { return 1; } for (int i = 1; i \u0026lt;= 22; i++) { int t1 = dfs(step+i, sum + a[step]); if (t1) { ans[ansn++] = a[step]; return 1; } } } int main() { cin \u0026gt;\u0026gt; n; if (n % 2 != 0) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } for (int i = 0; i \u0026lt; 23; i++) { if (n == a[i]) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; endl; return 0; } } dfs(0, 0);\tfor (int i = 0; i \u0026lt; ansn; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; } ç¬¬å››é¢˜ç›´æ¥æ— è„‘çˆ†æœï¼Œèƒ½æ‹¿åˆ°æš´åŠ›åˆ†å°± okã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long ans = -99999999999; int a[1005][1005], n, m; bool vis[1005][1005]; const int dx[3] = { -1, 1, 0 }; const int dy[3] = { 0, 0, 1 }; void dfs(int x, int y, long long sum) { if (x == n \u0026amp;\u0026amp; y == m) { // ç»ˆç‚¹ ans = max(ans, sum+a[x][y]); return ; } for (int i = 0; i \u0026lt; 3; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 1 || ny \u0026lt; 1 || nx \u0026gt; n || ny \u0026gt; m) continue; if (vis[nx][ny]) continue ; vis[nx][ny] = 1; dfs(nx, ny, sum + a[x][y]); vis[nx][ny] = 0; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); vis[i][j] = false; } } dfs(1, 1, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } å‡ºäº†è€ƒåœºä¹‹åå’Œ tjl å¯¹ç­”æ¡ˆï¼Œæ‰çŸ¥é“ç¬¬ä¸€é¢˜è€ƒçš„æ˜¯äºŒè¿›åˆ¶ï¼Œç¬¬äºŒé¢˜è¦ç”¨æ¡¶æ’åºã€‚ã€‚ã€‚\nç„¶åé‚£æ—¶ç«Ÿç„¶è¿˜æŒºä¹è§‚çš„ï¼Œè§‰å¾—æˆ‘çš„ä¹Ÿæ²¡é—®é¢˜ã€‚ã€‚ã€‚\nç”šè‡³è¿˜å¼€å§‹è®¨è®ºæœ‰æ²¡æœ‰ 1= ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚\nç›´åˆ°æ´›è°·ä¸Šäº†æ°‘é—´æ•°æ®è‡ªæµ‹ã€‚\n100 + 80 + 30 + 15 = 225\nè¿˜æ˜¯çœ‹çœ‹èƒ½ä¸èƒ½æœ‰äºŒç­‰å§ã€‚ã€‚\næ€»ä¹‹è¾¾åˆ°äº†è€ƒå‰çš„æœŸæœ›ï¼Œè€ƒåè¿˜æ˜¯å¤ªè‡ªä¿¡äº†ä¸€ç‚¹ç‚¹ã€‚ä¹Ÿæ²¡ä»€ä¹ˆé—æ†¾ï¼Œæ­£å¸¸å‘æŒ¥å‡ºäº†è‡ªå·±çš„æ°´å¹³ã€‚\né‚£ä¹ˆå°±ï¼š\nCSP-J/S 2021 RP++\nUPD: 215 åˆ†ï¼Œ2=\n","date":"November 2020","permalink":"https://blog.chungzh.cn/articles/csp-j-2020/","tags":["æ¸¸è®°","OI","CSP"],"title":"CSP-J 2020 æ¸¸è®°"},{"categories":"çæå¼€å‘","contents":" å‰è¨€ æœ€è¿‘å¼€å§‹å­¦ä¹  Qtï¼Œç„¶åå°±æŒ–å‘äº†ä¸€ä¸ªå°ç©å…· Notepandaï¼Œé¡ºä¾¿çœ‹çœ‹èƒ½ä¸èƒ½æ›¿ä»£è¯¸å¦‚ notepadã€gedit ä¹‹ç±»çš„è½¯ä»¶ã€‚é¡ºä¾¿é”»ç‚¼ä¸€ä¸‹è‡ªå·±ã€‚\nGitHub repo\nFeature åŸºæœ¬çš„æ–‡æœ¬ç¼–è¾‘æ“ä½œï¼ˆæ²¡æƒ³åˆ°å§è¿™ä¹Ÿæ˜¯ feature äº†å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼‰ è¡Œå·æ˜¾ç¤º è¯­æ³•é«˜äº® ä»å‘½ä»¤è¡Œå¯åŠ¨ã€‚ï¼ˆå¦‚ notepanda æˆ–è€… notepanda CMakeLists.txtï¼‰ é™¤æ­¤ä¹‹å¤–è¿˜å®ç°äº†è‡ªå®šä¹‰å­—ä½“ã€å­—å·ã€Qt ä¸»é¢˜å’Œ Status Bar ç­‰ä¸€äº›å°åŠŸèƒ½ã€‚\nä»¥åçš„ç›®æ ‡æ˜¯å®ç°å¤šæ ‡ç­¾é¡µï¼Œå¹¶å¯¹ Markdown åšä¸€ç‚¹ä¼˜åŒ–ï¼ˆæ¯”å¦‚é¢„è§ˆï¼‰ï¼Œå¦‚æœæœ‰å¯èƒ½è¿˜ä¼šåŠ è¿›å»ä¸€ä¸ª terminalã€‚è®¡åˆ’åœ¨ GitHub Projectsã€‚\nç›®å‰è¿˜æ˜¯å¾ˆå¼±çš„ä¸€ä¸ªä¸œè¥¿ï¼Œä¸è¿‡ç­‰æŸ¥æ‰¾ã€æ›¿æ¢ç­‰ feature å®ç°ä¹‹åï¼ŒåŸºæœ¬ä¸Šå¯ä»¥æ›¿ä»£ Windows çš„ notepad äº†ã€‚\nScreenshots å®ç° è¿™éƒ¨åˆ†å¤§æ¦‚è®²è®²æ€è·¯å§ã€‚\nå¸ƒå±€ ç¼–è¾‘æ§ä»¶ ä½¿ç”¨äº† Qt æä¾›çš„ QPlainTextEdit ç±»ï¼Œé€‚åˆçº¯æ–‡æœ¬ç¼–è¾‘ã€‚åˆšå¼€å§‹è¿˜ç”¨çš„æ˜¯ QTextEditï¼Œæƒ³æƒ³è‡ªå·±çœŸæ˜¯å‚»äº†ï¼Œåˆä¸æ˜¯è¦ç¼–è¾‘å¯Œæ–‡æœ¬å“ˆå“ˆå“ˆã€‚\nä¸è¿‡ QPlainTextEdit ä¼¼ä¹æœ‰ç‚¹ç‚¹æ…¢ï¼Œæˆ‘ä¹Ÿæ²¡èƒ½åŠ›é€ è½®å­ï¼Œäºæ˜¯å°±å°†å°±ç€ç”¨å§ã€‚\nè¯­æ³•é«˜äº® åˆšå¼€å§‹æƒ³å®ç°çš„æ—¶å€™çœ‹è§äº† Qt å®˜æ–¹çš„ Syntax Highlighter Exampleï¼Œå¾ˆæ£’å¯¹å§ã€‚ä½†æ˜¯æˆ‘å¯ä¸æƒ³èŠ±ç²¾åŠ›å»å†™ä¸€å †è¯­è¨€çš„è§„åˆ™å‘¢ï¼\nç„¶åå°±æ‰¾åˆ°äº† KDE Framework é‡Œçš„ KSyntaxHighlightingã€‚KDE Framework æ˜¯çœŸçš„çƒ¦äººï¼Œåˆšå¼€å§‹æ€ä¹ˆä¹Ÿ build ä¸å‡ºæ¥ã€‚ç­‰åˆ°äº† GitHub Actions ä¸Šï¼Œæ•´æ•´ç”¨äº†å››å¤©æ—¶é—´æ‰æå®šï¼Œè¿˜æ˜¯åœ¨æŸ Packman çš„å¸®åŠ©ä¸‹æ‰å®Œæˆçš„ã€‚ã€‚ã€‚å½“æ—¶çœ‹åˆ°ç»¿ç»¿çš„ Actionsï¼Œæˆ‘å·®ç‚¹æ²¡å¼€å¿ƒå¾—ç–¯æ‰ã€‚ã€‚\nè¿™ä¸ª KSyntaxHighlightingï¼Œdeepin-editor å’Œ Qt Creator éƒ½åœ¨ä½¿ç”¨ã€‚å¥½åœ¨ä»–è‡ªå·±ä¹Ÿæä¾›äº†ä¸€äº› exampleï¼Œçœ‹ä¸Šå»å¾ˆç®€å•ã€‚ä¾èµ–ä¹Ÿå¾ˆå°ï¼Œåªæœ‰ Extra CMake Modulesï¼Œä¸è¿‡çœ‹ä¸Šå»å’Œé«˜äº®çš„åŠŸèƒ½æ²¡å•¥å…³ç³»ï¼Œä¹Ÿè®¸æ˜¯ KF å¿…å¤‡ä¾èµ–å§ã€‚å®ƒè‡ªå¸¦äº†ä¸¤ç™¾å¤šç§è¯­è¨€çš„é«˜äº®è§„åˆ™ï¼Œçœäº†æˆ‘å¾ˆå¤šäº‹æƒ…ï¼Œæœ‰ Dark / Light ä¸»é¢˜ï¼Œä¸æœè¿˜å¯ä»¥è‡ªå·±å†™ã€‚å¾ˆæ»¡æ„ã€‚\nCI æˆ‘å¯ä¸æƒ³æ¯æ¬¡æ›´æ–°éƒ½è‡ªå·±æ‰“ä¸€æ¬¡åŒ…ï¼Œæ²¡é‚£ä¸ªé—²å¿ƒï¼Œæ‰‹ä¸Šèƒ½ç”¨çš„ç³»ç»Ÿä¹Ÿä¸å¤Ÿ :) ç©·å­©å­æ€ä¹ˆä¹°å¾—èµ· Macã€‚æ‰€ä»¥åªèƒ½ç”¨ CI å•¦ã€‚\nç°åœ¨ CI ä¸»è¦å¸®æˆ‘è§£å†³äº†ï¼š\nWindows å®‰è£…ç¨‹åº Windows ä¸Šçš„ 7z \u0026amp; MacOS ä¸Šçš„ dmg \u0026amp; Linux çš„ AppImage Release æ—¶è‡ªåŠ¨ä¸Šä¼ ä»¥ä¸Šæ‰€æœ‰æ–‡ä»¶ CI å¹³å°å½“ç„¶æ˜¯é€‰æ‹©äº† GitHub Actions å•¦ï¼ç°åœ¨è¿™ä¸ªé¡¹ç›®æ‰€æœ‰ç¯èŠ‚éƒ½åœ¨ GitHub ä¸Šèƒ½æ‰¾åˆ°ï¼ŒAUR é™¤å¤– :(\nNotepanda çš„ CI å…¨éƒ½æ˜¯æŠ„ Qv2ray ä¸Šçš„ï¼Œå¯çœŸæ˜¯å¸®äº†æˆ‘å¾ˆå¤šå¿™ã€‚\næœ€å æ„Ÿè°¢ Qv2ray çš„ Super Packman: ymshenyuï¼Œæ„Ÿè°¢æ­»é¬¼ gccï¼Œæ„Ÿè°¢é¸­é¸­ï¼Œæ„Ÿè°¢ Qv2ray User Group é‡Œé¢çš„æ¯ä¸€ä¸ªäººã€‚å¦‚æœæ²¡æœ‰ä»–ä»¬ï¼Œæˆ‘çš„ Qt æ—…ç¨‹ä¸ä¼šè¿™ä¹ˆé¡ºåˆ©ã€‚\né¡ºä¾¿ï¼ŒQv2ray æ˜¯ä¸€ä¸ªå¾ˆå¥½ç”¨çš„ v2ray è·¨å¹³å°å®¢æˆ·ç«¯ï¼Œæ¬¢è¿å°è¯•ï¼\nè°¢è°¢é˜…è¯» ğŸ™‡â€â™‚ï¸\næœ€åï¼Œæ”¾ä¸Šæˆ‘ç”»çš„ä¸€åªå°ç†ŠçŒ«ï¼š\n","date":"May 2020","permalink":"https://blog.chungzh.cn/articles/notepanda/","tags":["æ–‡æœ¬ç¼–è¾‘å™¨","Qt","C++"],"title":"Notepanda å¼€å‘å°ç»“"},{"categories":"çæå¼€å‘","contents":"åœ¨å¼€å‘ä¸­ç»å¸¸éœ€è¦æµ‹é‡æ—¶é—´ï¼Œæ¯”å¦‚æ€§èƒ½ä¼˜åŒ–æ—¶ï¼Œæ¯”è¾ƒä¸¤ç§æ–¹æ³•çš„è€—æ—¶ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè·å–å½“å‰çš„æ—¶é—´ä¹Ÿå¯ä»¥ç”¨äºåˆå§‹åŒ–éšæœºæ•°ç”Ÿæˆå™¨ã€‚è€Œ C++ æä¾›äº†å¾ˆç§æ–¹æ³•æ¥è·å–æ—¶é—´ã€‚\næ ‡å‡†åº“ std::time å®šä¹‰ è¿™ä¸ªå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªè·ç¦» UTC æ—¶é—´ 1970 å¹´ 1 æœˆ 1 æ—¥ 0:00 çš„ç§’æ•°ã€‚\nå¤´æ–‡ä»¶ï¼š\u0026lt;ctime\u0026gt;\næ–‡æ¡£ï¼šstd::time\n1 std::time_t time( std::time_t* arg ); ç”¨æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { time_t res_1 = time(nullptr); Sleep(1000); // do some stuff... time_t res_2 = time(nullptr); cout \u0026lt;\u0026lt; res_1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; asctime(localtime(\u0026amp;res_1)) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; res_2 - res_1 \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* è¾“å‡ºç»“æœ 1585457981 Sun Mar 29 12:59:41 2020 1s */ std::chrono::steady_clock::now å®šä¹‰ è¿”å›è¡¨ç¤ºå½“å‰æ—¶é—´çš„æ—¶é—´ç‚¹ã€‚\nè¿™ä¸ªæ—¶é’Ÿæ˜¯ä¸“é—¨ç”¨æ¥è®¡ç®—æ—¶é—´çš„é—´éš”çš„ã€‚C++ è¿˜æä¾›äº†ä¸€ä¸ª system_clockï¼Œç”¨äºè·å–ç³»ç»Ÿçš„æ—¶é—´ã€‚\nå¤´æ–‡ä»¶ï¼šchrono\næ–‡æ¡£ï¼šstd::chrono::stadey_clock\n1 2 static std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; now() noexcept; // (C++11 èµ·) ç”¨æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { chrono::steady_clock::time_point start = chrono::steady_clock::now(); Sleep(1000); // do some stuff... chrono::steady_clock::time_point end = chrono::steady_clock::now(); chrono::duration\u0026lt;double\u0026gt; ans = end - start; cout \u0026lt;\u0026lt; ans.count() \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* è¾“å‡ºï¼š 1.01495s */ Windows GetTickCount å®šä¹‰ æ£€æµ‹è‡ªç³»ç»Ÿå¯åŠ¨ä»¥æ¥ç»è¿‡çš„æ¯«ç§’æ•°ï¼Œæœ€å¤šä¸º 49.7 å¤©ã€‚å¦‚æœä¸å¤Ÿç”¨ï¼Œå¯ä»¥ä½¿ç”¨ GetTickCount64ã€‚\næ–‡æ¡£ï¼šGetTickCount function\n1 DWORD GetTickCount(); ç”¨æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { DWORD start = GetTickCount(); Sleep(1000); // do some stuff... DWORD end = GetTickCount(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /*è¾“å‡ºï¼š 1016ms */ GetTickCount64 å®šä¹‰ æ£€æµ‹è‡ªç³»ç»Ÿå¯åŠ¨ä»¥æ¥ç»è¿‡çš„æ¯«ç§’æ•°ã€‚\næ–‡æ¡£ï¼šGetTickCount64 function\n1 ULONGLONG GetTickCount64(); ç”¨æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ULONGLONG start = GetTickCount64(); Sleep(1000); // do some stuff... ULONGLONG end = GetTickCount64(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* è¾“å‡ºï¼š 1015ms */ QueryPerformanceCounter å®šä¹‰ æ£€æµ‹æ€§èƒ½è®¡æ•°å™¨çš„å½“å‰å€¼ï¼Œè¯¥å€¼æ˜¯ä¸€ä¸ªé«˜åˆ†è¾¨ç‡ï¼ˆ\u0026lt;1usï¼‰æ—¶é—´æˆ³ï¼Œå¯ç”¨äºæ—¶é—´é—´éš”æµ‹é‡ã€‚\nè¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªã€Œé»‘ç§‘æŠ€ã€ï¼Œç²¾åº¦éå¸¸é«˜ï¼Œç”¨èµ·æ¥ä¹Ÿç¨å¾®éº»çƒ¦ä¸€ç‚¹ç‚¹ã€‚\næ–‡æ¡£ï¼šQueryPerformanceCounter function\nç”¨æ³• 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { LARGE_INTEGER freq; QueryPerformanceFrequency(\u0026amp;freq); // è·å–æ€§èƒ½è®¡æ•°å™¨çš„é¢‘ç‡ LARGE_INTEGER start; QueryPerformanceCounter(\u0026amp;start); Sleep(1000); // do some stuff... LARGE_INTEGER end; QueryPerformanceCounter(\u0026amp;end); double misTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000000.0); // å¾®ç§’ double milTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000.0); // æ¯«ç§’ double sTime = (end.QuadPart - start.QuadPart) / freq.QuadPart; // ç§’ cout \u0026lt;\u0026lt; misTime \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; milTime \u0026lt;\u0026lt; \u0026#34; milliseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sTime \u0026lt;\u0026lt; \u0026#34; seconds\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* è¾“å‡ºï¼š 1.00367e+06 microseconds 1003.67 milliseconds 1 seconds */ è‡³æ­¤ï¼Œæœ¬æ–‡å…±ä»‹ç»äº†äº”ç§æµ‹é‡æ—¶é—´æ®µçš„æ–¹æ³•ã€‚\nä½œè€…å¾ˆèœï¼Œå¦‚å‘ç°ä»€ä¹ˆé—®é¢˜ï¼Œè¯·åœ¨è¯„è®ºåŒºä¸­æŒ‡å‡ºã€‚\nè°¢è°¢ ğŸ™‡â€â™‚ï¸\nReference Kurt Guntheroth. Optimized C++: Proven Techniques for Heightened Performance\nCppReference\nMicrosoft Docs\n","date":"March 2020","permalink":"https://blog.chungzh.cn/articles/cpp-get-time/","tags":["C++","Windows","æ—¶é—´"],"title":"Windows ä¸­ C++ æµ‹é‡æ—¶é—´çš„ N ç§æ–¹æ³•"},{"categories":"çæå¼€å‘","contents":" 0x00 ä»‹ç» tabulate tabulate æ˜¯ä¸€ä¸ªä½¿ç”¨ C++ 17 ç¼–å†™çš„åº“ï¼Œå®ƒå¯ä»¥åˆ¶ä½œè¡¨æ ¼ã€‚ä½¿ç”¨å®ƒï¼ŒæŠŠè¡¨æ ¼å¯¹é½ã€æ ¼å¼åŒ–å’Œç€è‰²ï¼Œä¸åœ¨è¯ä¸‹ï¼ä½ ç”šè‡³å¯ä»¥ä½¿ç”¨ tabulateï¼Œå°†ä½ çš„è¡¨æ ¼å¯¼å‡ºä¸º Markdown ä»£ç ã€‚ä¸‹å›¾æ˜¯ä¸€ä¸ªä½¿ç”¨ tabulate åˆ¶ä½œçš„è¡¨æ ¼è¾“å‡ºåœ¨å‘½ä»¤è¡Œçš„æ ·ä¾‹ï¼š\nå½“ç„¶ï¼Œé™¤äº†è¡¨æ ¼ï¼Œä½ è¿˜å¯ä»¥ç©å‡ºèŠ±æ ·ã€‚çœ‹è§ä¸‹é¢è¿™ä¸ªé©¬é‡Œå¥¥äº†å—ï¼Ÿè¿™ä¹Ÿæ˜¯ç”¨ tabulate åˆ¶ä½œçš„ï¼æºç åœ¨ è¿™é‡Œã€‚\n0x10 å‡†å¤‡ é¦–å…ˆä½ éœ€è¦å®‰è£… CMakeã€‚\nåˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼ˆä¸‹æ–‡ç”¨ X ä»£æ›¿ï¼‰ï¼Œä½œä¸ºä½ ä½¿ç”¨ tabulate çš„åœ°æ–¹ã€‚å†å°† include è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹è½½åˆ° X é‡Œã€‚ç„¶ååœ¨ X é‡Œåˆ›å»º main.cpp ä»¥åŠä¸€ä¸ª CMakeLists.txtã€‚\næ³¨æ„ï¼šéœ€è¦ä¸‹è½½ include æ•´ä¸ªæ–‡ä»¶å¤¹è€Œä¸æ˜¯ä»…ä»…ä¸‹è½½ tabulate æ–‡ä»¶å¤¹\nä½ å¯ä»¥ç‚¹å‡» è¿™é‡Œ ä¸‹è½½ tabulate é¡¹ç›®ï¼Œç„¶åå°† include æ–‡ä»¶å¤¹å¤åˆ¶åˆ° X ä¸­ã€‚\nå°†ä¸‹é¢çš„ä»£ç å¤åˆ¶è¿› CMakeLists.txt ï¼š\n1 2 3 4 5 6 7 8 9 10 11 cmake_minimum_required(VERSION 3.8) # è¿™é‡Œçš„ tabulateDemo å¯ä»¥æ¢ä¸ºä½ å–œæ¬¢çš„åå­— project(tabulateDemo) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED True) include_directories(include) add_executable(main main.cpp) æœ€å X æ–‡ä»¶å¤¹çš„ç»“æ„åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š\n1 2 3 4 5 . â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ include â”‚ â””â”€â”€ tabulate â””â”€â”€ main.cpp è¯·è®¤çœŸæ ¸å¯¹å¥½ X çš„ç»“æ„ï¼\nå¯å‰å¾€ ChungZH/tabulatedemo æ ¸å¯¹æ–‡ä»¶ç»“æ„ã€‚\n0x20 å°è¯•èº«æ‰‹ å°†ä¸‹é¢è¿™æ®µä»£ç å¤åˆ¶è¿› main.cpp ä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table hellogithub; // åˆ›å»ºä¸€ä¸ªå«åš hellogithub çš„ Table å¯¹è±¡ hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Linux/MacOS ç³»ç»Ÿï¼Œè¯·åœ¨ç»ˆç«¯è¿›å…¥ X æ–‡ä»¶å¤¹å¹¶è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š\n1 2 3 4 5 mkdir build cd build cmake .. make ./main å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Windows ç³»ç»Ÿå’Œ MinGWï¼Œè¯·æ£€æŸ¥æ˜¯å¦å®‰è£… mingw32-make.exeï¼Œå¹¶åœ¨ç»ˆç«¯ä¸­è¿›å…¥ X æ–‡ä»¶å¤¹ï¼Œè¾“å…¥ï¼š\n1 2 3 4 5 mkdir build cd build cmake .. mingw32-make ./main.exe å¦‚æœä½ ä½¿ç”¨ Windows ä»¥åŠ MSVCï¼Œåœ¨ç»ˆç«¯ä¸­è¾“å…¥ï¼š\n1 2 3 mkdir build cd build cmake .. ç„¶åä½¿ç”¨ Visual Studio æ‰“å¼€ build æ–‡ä»¶å¤¹ä¸‹çš„ tabulateDemo.sln æ¥è¿è¡Œã€‚\nå¦‚æœæ²¡æœ‰é—®é¢˜ï¼Œé‚£ä¹ˆä½ åº”è¯¥ä¼šåœ¨ç»ˆç«¯é‡Œçœ‹åˆ°ï¼š\n0x30 æ ¼å¼åŒ–è¡¨æ ¼ è¯·å…ˆè®¤çœŸåˆ†æ 0x20 å°è¯•èº«æ‰‹ ç« èŠ‚ä¸­çš„ä»£ç å¹¶å°è¯•ç€ä¿®æ”¹ä¸€ä¸‹å®ƒï¼\n0x31 Word Wrapping ä¸ºäº†é˜²æ­¢è¡¨æ ¼ä¸­çš„å†…å®¹è¿‡é•¿å¯¼è‡´ä¸æ•´é½ï¼Œä½ å¯ä»¥æŒ‡å®šè¡¨æ ¼æ¯ä¸€åˆ—çš„å®½åº¦ï¼Œtabulate å°±ä¼šè‡ªåŠ¨å¸®ä½ æ¢è¡Œã€‚è¯­æ³•å¦‚ä¸‹ï¼š\n1 2 // å°†è¡¨æ ¼ç¬¬ 0 è¡Œç¬¬ 0 åˆ—çš„å®½åº¦è®¾ä¸º20 table[0][0].format().width(20); é™¤äº†è‡ªåŠ¨æ¢è¡Œï¼Œä½ ä¹Ÿå¯ä»¥åœ¨å†…å®¹ä¸­ä½¿ç”¨ \\n æ¥æ‰‹åŠ¨è®¾ç½®æ¢è¡Œã€‚\nè¿™æ˜¯ä¸€ä¸ª Word Wrapping çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;This paragraph contains a veryveryveryveryveryverylong word. The long word will break and word wrap to the next line.\u0026#34;, \u0026#34;This paragraph \\nhas embedded \u0026#39;\\\\n\u0026#39; \\ncharacters and\\n will break\\n exactly where\\n you want it\\n to\\n break.\u0026#34;}); table[0][0].format().width(20); // è®¾ç½®ç¬¬ 0 è¡Œç¬¬ 0 åˆ—çš„å®½åº¦ä¸º 20 table[0][1].format().width(50); // è®¾ç½®ç¬¬ 0 è¡Œç¬¬ 1 åˆ—çš„å®½åº¦ä¸º 50 cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; endl; return 0; } return 0; } ç¬¬ 0 è¡Œç¬¬ 0 åˆ—çš„æ–‡å­—æ˜¯ä¸æ˜¯å¾ˆé•¿ï¼Ÿä½†æ˜¯è®¾ç½®äº†å®ƒçš„å®½åº¦åï¼Œå°±ä¸ç”¨æ‹…å¿ƒäº†ã€‚tabulate å°†ä¼šå¸®ä½ è‡ªåŠ¨æ¢è¡Œã€‚å¦‚æœä¸è®¾ç½®çš„è¯ï¼Œè¡¨æ ¼å°±ä¼šå˜å¾—å¾ˆä¸æ•´é½ï¼Œä½ ä¹Ÿå¯ä»¥å°è¯•ä¸€ä¸‹ã€‚\nç¬¬ 0 è¡Œç¬¬ 1 åˆ—çš„å†…å®¹é‡Œè¿ç”¨äº†\\n çš„æ¢è¡Œç¬¦ï¼Œæ‰€ä»¥å³ä½¿æˆ‘ä»¬ç»™å®ƒè®¾ç½®äº† 50 çš„å®½åº¦ï¼Œä¹Ÿä¼šå…ˆæ ¹æ®å†…å®¹é‡Œçš„ \\n æ¢è¡Œç¬¦æ¥æ¢è¡Œã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œtabulate ä¼šè‡ªåŠ¨åˆ é™¤æ¯ä¸€è¡Œå†…å®¹ä¸¤è¾¹çš„ç©ºç™½å­—ç¬¦ã€‚\n0x32 å­—ä½“å¯¹é½ tabulate æ”¯æŒä¸‰ç§å¯¹é½è®¾ç½®ï¼šå·¦ã€ä¸­å’Œå³ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå…¨éƒ¨å†…å®¹éƒ½ä¼šé å·¦å¯¹é½ã€‚\nè¦æ‰‹åŠ¨è®¾ç½®å¯¹é½æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨ .format().font_align(æ–¹å‘)ã€‚\nä¸¾ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format() .font_align(FontAlign::center); // è®¾ç½®å±…ä¸­å¯¹é½ hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_align(FontAlign::left); // è®¾ç½®é å·¦å¯¹é½ hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_align(FontAlign::center); // è®¾ç½®å±…ä¸­å¯¹é½ hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); hellogithub[3][0].format() .font_align(FontAlign::right); // è®¾ç½®é å³å¯¹é½ hellogithub[0][0].format().width(50); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } 0x33 å­—ä½“æ ·å¼ tabulate æ”¯æŒä»¥ä¸‹å…«ç§å­—ä½“æ ·å¼ï¼š\nç²—ä½“ bold\næ·±è‰² dark\næ–œä½“ italic\nä¸‹åˆ’çº¿ underline\né—ªçƒ blink ï¼ˆï¼Ÿï¼‰\nç¿»è½¬ reverse\néšè— concealed\nåˆ é™¤çº¿ crossed\næŸäº›æ ·å¼å¯èƒ½ä¼šå› ä¸ºç»ˆç«¯çš„åŸå› è€Œæ— æ³•æ˜¾ç¤ºã€‚\nå¦‚ï¼šç²—ä½“ã€æ·±è‰²ã€æ–œä½“ã€é—ªçƒç­‰æ ·å¼ï¼Œè¯·æ…ç”¨ã€‚\nè¦ä½¿ç”¨è¿™äº›æ ·å¼ï¼Œå¯ä»¥è°ƒç”¨ .format().font_style({...})ã€‚æ ·å¼ä¹Ÿå¯ä»¥å åŠ ä½¿ç”¨ã€‚\n0x34 é¢œè‰² ä½ å¯ä»¥å¯¹è¡¨æ ¼çš„å­—ä½“ã€è¾¹æ¡†ã€è§’ä»¥åŠåˆ—åˆ†éš”ç¬¦å·è®¾ç½®å®ƒä»¬çš„å‰æ™¯æˆ–èƒŒæ™¯é¢œè‰²ã€‚\ntabulate æ”¯æŒ 8 ç§é¢œè‰²ï¼š\nç°è‰² gray\nçº¢è‰² red\nç»¿è‰² green\né»„è‰² yellow\nè“è‰² blue\næ´‹çº¢è‰² magenta\né’è‰² cyan\nç™½è‰² white\nå¯ä»¥é€šè¿‡ .format().\u0026amp;lt;element\u0026amp;gt;_color(é¢œè‰²) çš„æ–¹å¼å®šä¹‰å‰æ™¯è‰²æˆ–é€šè¿‡ .format().\u0026amp;lt;element\u0026amp;gt;_background_color(é¢œè‰²) çš„æ–¹å¼å®šä¹‰èƒŒæ™¯è‰²ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table colors; colors.add_row({\u0026#34;Font Color is Red\u0026#34;, \u0026#34;Font Color is Blue\u0026#34;, \u0026#34;Font Color is Green\u0026#34;}); colors.add_row({\u0026#34;Everything is Red\u0026#34;, \u0026#34;Everything is Blue\u0026#34;, \u0026#34;Everything is Green\u0026#34;}); colors.add_row({\u0026#34;Font Background is Red\u0026#34;, \u0026#34;Font Background is Blue\u0026#34;, \u0026#34;Font Background is Green\u0026#34;}); colors[0][0].format() .font_color(Color::red) .font_style({fonttyle::bold}); colors[0][1].format() .font_color(Color::blue) .font_style({fonttyle::bold}); colors[0][2].format() .font_color(Color::green) .font_style({fonttyle::bold}); colors[1][0].format() .border_left_color(Color::red) .border_left_background_color(Color::red) .font_background_color(Color::red) .font_color(Color::red); colors[1][1].format() .border_left_color(Color::blue) .border_left_background_color(Color::blue) .font_background_color(Color::blue) .font_color(Color::blue); colors[1][2].format() .border_left_color(Color::green) .border_left_background_color(Color::green) .font_background_color(Color::green) .font_color(Color::green) .border_right_color(Color::green) .border_right_background_color(Color::green); colors[2][0].format() .font_background_color(Color::red) .font_style({fonttyle::bold}); colors[2][1].format() .font_background_color(Color::blue) .font_style({fonttyle::bold}); colors[2][2].format() .font_background_color(Color::green) .font_style({fonttyle::bold}); cout \u0026lt;\u0026lt; colors \u0026lt;\u0026lt; endl; return 0; } 0x35 è¾¹æ¡†ã€è§’ ä½ å¯ä»¥å¯¹è¡¨æ ¼çš„è¾¹æ¡†å’Œè§’çš„æ–‡æœ¬ã€é¢œè‰²æˆ–èƒŒæ™¯é¢œè‰²è¿›è¡Œè‡ªå®šä¹‰ã€‚\nä½ å¯ä»¥ä½¿ç”¨ .corner(..)ã€.corner_color(..) å’Œ corner_background_color(..)Â æ¥å¯¹æ‰€æœ‰çš„è§’è®¾ç½®ä¸€ä¸ªå…±åŒçš„æ ·å¼ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ .border(..)Â ã€.border_color(..) å’Œ .border_background_color(..)Â æ¥å¯¹æ‰€æœ‰çš„è¾¹æ¡†è®¾ç½®ä¸€ä¸ªå…±åŒçš„æ ·å¼ã€‚\nè¿™æ˜¯ä¸€ä¸ªå•ç‹¬è®¾å®šæ‰€æœ‰è¾¹æ¡†å’Œè§’çš„ç¤ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;tabulate/table.hpp\u0026gt; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;á›ášºá›á›Š á›á›Š áš¨ á›Šá›á›Ÿáš±y á›Ÿáš áš¨ á›’á›–áš¨áš± áš¨áš¾á›\\n\u0026#34; \u0026#34;áš¨ áš¹á›Ÿá›šáš , áš¹ášºá›Ÿ áš¹áš¨áš¾á›á›–áš±á›–á› á›ášºá›–\\n\u0026#34; \u0026#34;áš±á›–áš¨á›šá›—á›Š áš¾á›áš¾á›– á›á›Ÿ áš áš¢á›šáš á›á›šá›š áš¨ á›ˆáš±á›Ÿá›—á›á›Šá›–\\n\u0026#34; \u0026#34;á›á›Ÿ á›Ÿáš¾á›– á›’á›–áš á›Ÿáš±á›–; á›ášºá›–y áš¹áš¨á›šáš² á›ášºá›–\\n\u0026#34; \u0026#34;á›áš¹á›á›šá›áš·ášºá› á›ˆáš¨á›ášº, á›á›–á›Šá›á›áš¾á›–á› á›á›Ÿ\\n\u0026#34; \u0026#34;á›á›á›Šcá›Ÿáš¹á›–áš± á›ášºá›– á›áš±áš¢á›ášº\\ná›ášºáš¨á› á›á›Š á›á›Ÿ cá›Ÿá›—á›–.\u0026#34;}); table.format() .multi_byte_characters(true) // Font styling .font_style({fonttyle::bold, fonttyle::dark}) .font_align(FontAlign::center) .font_color(Color::red) .font_background_color(Color::yellow) // Corners .corner_top_left(\u0026#34;á›°\u0026#34;) .corner_top_right(\u0026#34;á›¯\u0026#34;) .corner_bottom_left(\u0026#34;á›®\u0026#34;) .corner_bottom_right(\u0026#34;á›¸\u0026#34;) .corner_top_left_color(Color::cyan) .corner_top_right_color(Color::yellow) .corner_bottom_left_color(Color::green) .corner_bottom_right_color(Color::red) // Borders .border_top(\u0026#34;á›œ\u0026#34;) .border_bottom(\u0026#34;á›œ\u0026#34;) .border_left(\u0026#34;áš¿\u0026#34;) .border_right(\u0026#34;á›†\u0026#34;) .border_left_color(Color::yellow) .border_right_color(Color::green) .border_top_color(Color::cyan) .border_bottom_color(Color::red); std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; return 0; } 0x36 åŸºäºèŒƒå›´çš„è¿­ä»£ ä¸€ä¸ªä¸€ä¸ªè®¾ç½®è¡¨æ ¼çš„æ ·å¼æ˜¯ä¸æ˜¯å¾ˆéº»çƒ¦ï¼Ÿtabulate æä¾›äº†è¿­ä»£å™¨ï¼Œæ”¯æŒå¯¹è¡¨ã€è¡Œå’Œåˆ—çš„è¿­ä»£ï¼Œæ›´æ–¹ä¾¿åœ°æ ¼å¼åŒ–è¡¨æ ¼ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;tabulate/table.hpp\u0026gt; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;Company\u0026#34;, \u0026#34;Contact\u0026#34;, \u0026#34;Country\u0026#34;}); table.add_row({\u0026#34;Alfreds Futterkiste\u0026#34;, \u0026#34;Maria Anders\u0026#34;, \u0026#34;Germany\u0026#34;}); table.add_row({\u0026#34;Centro comercial Moctezuma\u0026#34;, \u0026#34;Francisco Chang\u0026#34;, \u0026#34;Mexico\u0026#34;}); table.add_row({\u0026#34;Ernst Handel\u0026#34;, \u0026#34;Roland Mendel\u0026#34;, \u0026#34;Austria\u0026#34;}); table.add_row({\u0026#34;Island Trading\u0026#34;, \u0026#34;Helen Bennett\u0026#34;, \u0026#34;UK\u0026#34;}); table.add_row({\u0026#34;Laughing Bacchus Winecellars\u0026#34;, \u0026#34;Yoshi Tannamuri\u0026#34;, \u0026#34;Canada\u0026#34;}); table.add_row({\u0026#34;Magazzini Alimentari Riuniti\u0026#34;, \u0026#34;Giovanni Rovelli\u0026#34;, \u0026#34;Italy\u0026#34;}); // è®¾ç½®æ¯ä¸€è¡Œçš„å®½åº¦ table.column(0).format().width(40); table.column(1).format().width(30); table.column(2).format().width(30); // éå†ç¬¬ä¸€è¡Œä¸­çš„å•å…ƒæ ¼ for (auto\u0026amp; cell : table[0]) { cell.format() .font_style({fonttyle::underline}) .font_align(FontAlign::center); } // éå†ç¬¬ä¸€åˆ—ä¸­çš„å•å…ƒæ ¼ for (auto\u0026amp; cell : table.column(0)) { if (cell.get_text() != \u0026#34;Company\u0026#34;) { cell.format() .font_align(FontAlign::right); } } // éå†è¡¨æ ¼ä¸­çš„è¡Œ size_t index = 0; for (auto\u0026amp; row : table) { row.format() .font_style({fonttyle::bold}); // è½®æµæŠŠæ•´è¡Œçš„èƒŒæ™¯è®¾ä¸ºè“è‰² if (index \u0026gt; 0 \u0026amp;\u0026amp; index % 2 == 0) { for (auto\u0026amp; cell : row) { cell.format() .font_background_color(Color::blue); } } index += 1; } std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; } 0x37 åµŒå¥—è¡¨æ ¼ åœ¨ tabulate ä¸­åµŒå¥—è¡¨æ ¼å¾ˆå®¹æ˜“ï¼Œå› ä¸º Table.add_row(...) è¿™ä¸ªå‡½æ•°å¯ä»¥æ¥å— std::string ç±»å‹å’Œ tabulate::Tableã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªåµŒå¥—è¡¨æ ¼çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0] .format() .font_background_color(Color::blue) .font_align(FontAlign::center); Table hglink; hglink.add_row({\u0026#34;GitHub repo\u0026#34;, \u0026#34;Website\u0026#34;}); hglink.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;, \u0026#34;hellogithub.com\u0026#34;}); hellogithub.add_row({hglink}); // åµŒå¥—ï¼ cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } 0x40 å¯¼å‡º 0x41 Markdown å¯ä»¥ä½¿ç”¨ MarkdownExporter æ¥å°†ä¸€ä¸ªè¡¨æ ¼å¯¼å‡ºä¸º GFM é£æ ¼çš„ Markdownã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/markdown_exporter.hpp\u0026#34; // æ³¨æ„è¿™ä¸ªå¤´æ–‡ä»¶ #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format().font_style({fonttyle::bold}); // åŠ ç²—æ ·å¼ï¼Œåœ¨ Markdown ä¸­å¯ä»¥è¡¨ç°å‡ºæ¥ hellogithub.add_row({\u0026#34;GitHub repo: github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;Website: hellogithub.com\u0026#34;}); // å¯¼å‡ºä¸º Markdown MarkdownExporter exporter; auto markdown = exporter.dump(hellogithub); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Markdown Source:\\n\\n\u0026#34; \u0026lt;\u0026lt; markdown \u0026lt;\u0026lt; endl; return 0; } å¯¼å‡ºæ•ˆæœå¦‚ä¸‹ï¼š\nHelloGitHub GitHub repo: github.com/521xueweihan/HelloGitHub Website: hellogithub.com æ³¨æ„ï¼šMarkdown ä¸èƒ½æŒ‡å®šæ¯ä¸€ä¸ªå•å…ƒæ ¼çš„å¯¹é½æ ·å¼ï¼Œåªèƒ½æŒ‡å®šä¸€åˆ—çš„å¯¹é½æ ·å¼ï¼Œåƒè¿™æ · hg.column(1).format().font_align(FontAlign::center);ã€‚\n0x50 å°¾å£° å¦‚æœæƒ³è¦æ›´è¯¦ç»†åœ°äº†è§£ tabulate çš„ç”¨æ³•ï¼Œè¯·æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ https://github.com/p-ranav/tabulate ã€‚\næœ¬æ–‡æ˜¯ä½œè€…çš„ç¬¬ä¸€æ¬¡å…³äºæ­¤ç±»å‹æ–‡ç« çš„å°è¯•ï¼Œå¦‚æœ‰ä¸è¶³ä¹‹å¤„ï¼Œè¯·æŒ‡æ­£ï¼Œè°¢è°¢ï¼\nå†è§ï¼\n","date":"February 2020","permalink":"https://blog.chungzh.cn/articles/tabulate/","tags":["C++"],"title":"ä¼˜é›…åœ°ä½¿ç”¨ C++ åˆ¶ä½œè¡¨æ ¼ï¼štabulate"},{"categories":null,"contents":"","date":"January 0001","permalink":"https://blog.chungzh.cn/archives/","tags":null,"title":"Archives"},{"categories":null,"contents":" æˆ‘ å°±æ˜¯ä¸ªèœé¸¡ã€‚\nä»Šå¹´åˆä¸‰ã€‚\nå…³äºæœ¬ç«™ æœ¬ç«™ä½¿ç”¨ Hugo æ­å»ºã€‚è¯¦è§ï¼š GitHub: ChungZH.github.ioã€‚\nå¦‚æ— ç‰¹æ®Šè¯´æ˜ï¼Œæœ¬ç«™çš„å†…å®¹å‡ä½¿ç”¨ CC BY-NC-SA 2.5 åè®®ã€‚\n","date":"January 0001","permalink":"https://blog.chungzh.cn/about/","tags":null,"title":"å…³äº"},{"categories":null,"contents":"æ¬¢è¿åŠ å‹é“¾å“¦ï¼å…ˆå‹åé“¾~\næœ‰æ„è€…æ¬¢è¿å‰å¾€ GitHub - ChungZH.github.io æäº¤ä¸€ä¸ª PRï¼Œåœ¨æœ¬é¡µé¢åŠ ä¸Šä½ çš„é“¾æ¥ã€‚æˆ–è€…å‘é‚®ä»¶ç»™æˆ‘ä¹Ÿæ˜¯å¯ä»¥çš„å“¦ï¼é‚®ç®±æ˜¯ï¼šchungzh07[AT]gmail.comã€‚\nKoufan keithxodoy æ³« å¤§å°¾å·´è‹å¡å¡çš„æœ‰åº•æ´ GogesL zzzmh JunzhouLiu j0ck1e Alliot\u0026rsquo;s blog CareyQ Zidone Yi-yun Alpha1022 Vigorous Pro å·¦æ‰‹çš„ä¸–ç•Œ PRIN BLOG Artin\u0026rsquo;s Blog EpLiar Coelacanthus Louis Aeilot\u0026rsquo;s blog Molink Eritque arcus Moody\u0026rsquo;s æ”¶è—å¤¹ï¼š\n%%%%%%\nmatrix67 å¾ˆå¤šæœ‰è¶£çš„æ•°å­¦é¢˜ Menci\u0026rsquo;s OI blog M_sea xht37 wjyyy Siyuan ","date":"January 0001","permalink":"https://blog.chungzh.cn/friends/","tags":null,"title":"å‹é“¾"}]