[{"categories":null,"contents":" CSP-J/S 认证注意事项：\n\u0026hellip;\u0026hellip;\n11. 祝各位选手好运。\n    CSP-J1  初赛前有点小紧张。\n赛前勉强做了几套试卷，然后就上考场了。\n刚考完对答案的时候发现 J 组才 72，看洛谷上大家都说今年 J 组简单了 blabla，分数线肯定会升，然而我却觉得好难，那一个星期都害怕极了。。。结果分数出来了才发现洛谷那群人真是扯啊哈哈哈\nS 组才 48 分，没有成功压线。（其实就算去了复赛也拿不了分。。\n   CSP-J2  比赛前一晚上八点在学校出发。逃掉了晚自习（尽管是星期五\n去到酒店大概也九点半了，洗完澡，看了会儿凤凰台，然后就睡了。\n第二天早上六点半起床，吃完自助餐（和上一年的变化不大，挺好吃的），七点二十出发。\n然后进考场。\n电脑好像是 Ryzen 3600，8GB 内存。\n八点半开考。\n密码很乱，6ewid\\n16384#，监考员一开始还直接忽略最后面那个井号了。。。\n打开题目，发现第一第二题题面好长，有点慌了起来\u0026hellip;\nT2 尤为毒瘤，到了 9:22 才搞完了。。。感觉挺很危险的，好怕翻车。\n10:08，肝完 T3，77 行代码，写完人都瘫了。。感谢第三个样例，一个一个找情况。。。\n（不知道怎么比对两个文件的内容，于是直接打开 Sublime Text 开始用查找来找不同。。。\n赶紧吃了根士力架，然后去上了个厕所。\n10:55，T4 过样例了，打得比 T3 轻松多了，当然也不可能拿满分。。。其实也不知道该怎么做，直接乱搞，做法非常诡异。。看看效果怎样吧，能骗到 50 分就是胜利。\n还有一点，今年 NOI Linux 2 还行。（毕竟上一年给了虚拟机但是系统有密码，根本打不开，笑死）在里面编译了几次代码，虽然也没什么用。运行起来还蛮快的。\n 总的来说，这次考得还行。题目有点诡异，没有 dp，没有搜索，个人感觉侧重考基本功。\n等成绩吧。\n UPD 1 (2021/10/23 22:50)：\n广东源代码出了。\n candy:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; long long n, L, R; int main() { freopen(\u0026#34;candy.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;candy.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; long long LRCHA = (R-L+1); long long LCN = L/n, RCN = R/n; if (RCN \u0026gt; LCN) { cout \u0026lt;\u0026lt; n-1 \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; R-LCN*n \u0026lt;\u0026lt; endl; return 0; }   sort:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int n, Q; long long a[8005]; int idxa[8005]; bool cmp(int i1, int i2) { if (a[i1] != a[i2]) return a[i1] \u0026lt; a[i2]; return i1 \u0026lt; i2; } int main() { freopen(\u0026#34;sort.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;sort.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;Q); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); while (Q--) { int type; scanf(\u0026#34;%d\u0026#34;, \u0026amp;type); if (type == 1) { // �޸� \tint x; long long v; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;x, \u0026amp;v); a[x] = v; for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); } else if (type == 2) { // ��ѯ \tint x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int i = 1; i \u0026lt;= n; i++) { if (idxa[i] == x) { printf(\u0026#34;%d\\n\u0026#34;, i); break; } } } } return 0; }   network:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int n; bool checkPrevZero(const string number) { if (number.length() \u0026gt; 1 \u0026amp;\u0026amp; number[0] == \u0026#39;0\u0026#39;) return true; return false; } int strToInt(const string number) { int t = 0; for (int i = 0; i \u0026lt; number.length(); i++) { t *= 10; t += number[i]-\u0026#39;0\u0026#39;; } return t; } bool check(const string addr) { int cntDot = 0, cntMao = 0; int dotIdx[3], maoIdx;\tif (!(addr[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[0] \u0026lt;= \u0026#39;9\u0026#39;) || !(addr[addr.length()-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[addr.length()-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; for (int i = 0; i \u0026lt; addr.length(); i++) { if (addr[i] == \u0026#39;.\u0026#39;) { if (cntDot \u0026gt; 2) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntDot++; dotIdx[cntDot-1] = i; } else if (addr[i] == \u0026#39;:\u0026#39;) { if (cntMao \u0026gt; 1) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntMao++; maoIdx = i; } else if (!(addr[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i] \u0026lt;= \u0026#39;9\u0026#39;)) { return false; } } if (!(cntDot == 3 \u0026amp;\u0026amp; cntMao == 1)) return false; if (maoIdx \u0026lt; dotIdx[2]) return false; string n1 = addr.substr(0, dotIdx[0]), n2 = addr.substr(dotIdx[0]+1, dotIdx[1]-dotIdx[0]-1), n3 = addr.substr(dotIdx[1]+1, dotIdx[2]-dotIdx[1]-1), n4 = addr.substr(dotIdx[2]+1, maoIdx-dotIdx[2]-1), n5 = addr.substr(maoIdx+1, addr.length()-maoIdx-1); //cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n4 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n5 \u0026lt;\u0026lt; endl; \tif (checkPrevZero(n1) || checkPrevZero(n2) || checkPrevZero(n3) || checkPrevZero(n4) || checkPrevZero(n5)) return false; if (n1.length() \u0026gt; 3 || n2.length() \u0026gt; 3 || n3.length() \u0026gt; 3 || n4.length() \u0026gt; 3 || n5.length() \u0026gt; 5) return false; int a = strToInt(n1), b = strToInt(n2), c = strToInt(n3), d = strToInt(n4), e = strToInt(n5); if (a \u0026gt; 255 || b \u0026gt; 255 || c \u0026gt; 255 || d \u0026gt; 255 || e \u0026gt; 65535) return false; return true; } int serversNum = 0; map\u0026lt;string, int\u0026gt; servers; int main() { freopen(\u0026#34;network.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;network.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n; string op, ad; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; ad; if (!check(ad)) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } if (op == \u0026#34;Server\u0026#34;) { if (servers[ad] != 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } servers[ad] = i+1; cout \u0026lt;\u0026lt; \u0026#34;OK\\n\u0026#34;; } else if (op == \u0026#34;Client\u0026#34;) { if (servers[ad] == 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } cout \u0026lt;\u0026lt; servers[ad] \u0026lt;\u0026lt; endl; } } return 0; }   fruit:  （代码非常奇妙，思路十分无理，建议不要看）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct node { int idx; int val; int ai; int len; }; int n; int a[200005]; vector\u0026lt;node\u0026gt; sons[405005]; int nodeNums = 1; void buildtree(int root, int left, int right, bool rrr) { if (rrr) { int prev = 1; for (int i = 2; i \u0026lt;= n; i++) { if (a[i] != a[prev]) { sons[1].push_back({nodeNums+1, a[prev], prev, i-prev}); buildtree(nodeNums+1, prev, i-1, 0); nodeNums++; prev = i; } } sons[1].push_back({nodeNums+1, a[prev], prev, n-prev+1}); buildtree(nodeNums+1, prev, n, 0); nodeNums++; } else { for (int i = left; i \u0026lt;= right; i++) { sons[root].push_back({++nodeNums, a[left], i, 1}); } } } void work() { for (int i = 0; i \u0026lt; sons[1].size(); i++) { printf(\u0026#34;%d \u0026#34;, sons[sons[1][i].idx][0].ai); sons[sons[1][i].idx].erase(sons[sons[1][i].idx].begin()); if (sons[sons[1][i].idx].size() == 0) { sons[1].erase(sons[1].begin()+i); i--; } } // merge \tfor (int i = 1; i \u0026lt; sons[1].size(); i++) { if (sons[1][i].val != sons[1][i-1].val) continue; int id = sons[1][i].idx; for (int j = 0; j \u0026lt; sons[id].size(); j++) { sons[sons[1][i-1].idx].push_back(sons[id][j]); } sons[1].erase(sons[1].begin()+i); i--; } printf(\u0026#34;\\n\u0026#34;); } int main() { freopen(\u0026#34;fruit.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;fruit.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } buildtree(1, 1, n, 1); while (sons[1].size()) { work(); } return 0; }   洛谷自测：342 = 100 + 72 + 100 + 70\n计蒜客自测：342 = 100 + 52 + 100 + 90\n目前看上去 1= 稳了。\n UPD 2 (2021/10/30 22:38)：\nCCF 官方：100 + 52 + 100 + 70 = 322\n","date":"Oct 23","permalink":"https://blog.chungzh.cn/articles/csp2021/","tags":["游记","信息学","CSP","CCF"],"title":"CSP-J 2021 游记"},{"categories":null,"contents":"线段树是一种高端的数据结构，可以用来在区间上进行信息统计。它能够在 $O(logN)$ 的时间复杂度内实现单点/区间修改、区间找最大值/最小值/总和/\u0026hellip;，适用于大规模的区间统计。\n如下图就是一棵线段树。在结点中，你可以存对应区间的最大值，最小值，总和等等。\n对于每一个结点 $i$，它的两个子结点分别是 $2i$ 和 $2i+1$。因此，在开树的数组时，最好要开到 $4N$ 的大小。\n 关于 $4N$，详见 OI-Wiki。\n    建树  下面是一个求区间和的线段树的建树代码。\n通过 DFS 建树，到叶结点，然后一路回溯求出和。\n1 2 3 4 5 6 7 8 9 10 11 12 13  void build_tree(int cur, int left, int right) { // cur 为当前树的根，[left, right] 是当前树对应的区间 \tif (left == right) { // 到叶子节点了，区间长度为 1，总和就是它本身 \ttree[cur] = a[left]; return ; } int leftSon = cur*2, rightSon = leftSon+1; int mid = (left+right)/2; build_tree(leftSon, left, mid); build_tree(rightSon, mid+1, right); tree[cur] = tree[leftSon]+tree[rightSon]; // 求和 }   这里求 leftSon，rightSon，mid 的模式在线段树的所有操作中都会用到。\n   区间查询  对于一个不恰好的区间，我们可以不断地把它拆分成两个恰好的区间再进行合并。\n如图所示，拆分过程如下：\n [3, 7] [3, 4], [5, 7] [3, 4], [5, 6], [7, 7]  在实际 DFS 过程中，我们可以分为三种情况：\n 当前结点对应区间和要查询的区间完全无关，直接退出 当前结点对应区间完全处于要查询的区间范围，返回当前结点的值 两个区间部分相交，继续拆分为 1 或 2 情况  1 2 3 4 5 6 7 8 9  long long query(int cur, int l, int r, int x, int y) { // cur 为当前树的根，[l, r] 是当前树对应的区间，[x, y] 是要查询的区间 \tif (y \u0026lt; l || r \u0026lt; x) return 0; // 1. 相离 \tif (x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) return tree[cur]; // 2. 完全包含 \t// 3. 相交 \tint leftSon = cur*2, rightSon = leftSon+1; int mid = (l+r)/2; return query(leftSon, l, mid, x, y) + query(rightSon, mid+1, r, x, y); // 求和 }      区间修改  单点修改并没有什么意思，就不讲了。\n区间修改当然不是重复做单点修改，否则使用线段树就很没有必要了。为了避免走到底下去，我们要使用一个懒惰标记（lazy tag）。当一个大区间内所有的小单位都要进行同样的修改操作时，只需要在大区间做一次标记就可以了。到了必须要走下去（即查询更小的区间或修改更小的区间）的时候，再把懒惰标记下放。\n下面以一个区间增加一个值并进行区间查询为例。\n首先定义一个结构体，其中 add 就是记录这个区间需要增加的值。\n1 2 3 4  struct node { long long sum, add; } tree[4 * MAXN];   下放操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13  void pushdown(int cur, int left, int mid, int right) { // 将当前结点的 add 值下放给子结点  const int leftSon = cur * 2, rightSon = leftSon + 1; // 更新总和（区间元素个数*每个元素要增加的值）  tree[leftSon].sum += (mid - left + 1) * tree[cur].add; tree[rightSon].sum += (right - mid) * tree[cur].add; // 更新 add 值  tree[leftSon].add += tree[cur].add; tree[rightSon].add += tree[cur].add; // 当前结点的懒惰标记已经下放，需要清零  tree[cur].add = 0; }   区间增加一个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void update(int cur, int left, int right, int x, int y, ll c) { if (left \u0026gt; y || right \u0026lt; x) // 相离  return; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // 完全包含  { // 给当前区间整体增加 c  tree[cur].sum += (right - left + 1) * c; // 打标记  tree[cur].add += c; // 这时不需要子结点的值，所以不必下放  return; } // 相交 \t// 分成两个子区间，必须要往下走了  int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // 先下放标记  update(leftSon, left, mid, x, y, c); update(rightSon, mid + 1, right, x, y, c); tree[cur].sum = tree[2 * cur].sum + tree[2 * cur + 1].sum; // 最后汇总总和 }   区间查询：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ll query(int cur, int left, int right, int x, int y) { if (left \u0026gt; y || right \u0026lt; x) // 相离  return 0; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // 完全包含  return tree[cur].sum; // 相交 \t// 拆成两个字区间再求和  int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // 必须往下走，下放标记  return query(leftSon, left, mid, x, y) + query(rightSon, mid + 1, right, x, y); }   通过上面的代码，我们可以看到：懒惰标记就是为了不往下走，尽量在更大的区间做一次操作。必要时才往下下放标记。它不会主动做事，而是到你需要的时候才花时间去做。通过这样节省了很多时间。\n   小结  总的来说，线段树不是一个很难的数据结构，但是很实用。\n感谢 lgj 老师！\n","date":"Aug 04","permalink":"https://blog.chungzh.cn/articles/segment-tree/","tags":["OI","数据结构","线段树"],"title":"线段树学习笔记"},{"categories":null,"contents":" *** 你 * 什么时候 * 啊？\n 好不容易才从期末的阴霾中摆脱，欢乐地进入了暑假。\n十五天的补习？不慌。十天的信息学夏令营？没事，确实对我有帮助。\n\u0026hellip;\u0026hellip;\n于是还是开始了美好的暑假生活。\n不过就在今天，老师突然在群里发了一则消息：\n 优秀的各位家长：\n*** 班初定 7 月 22 日至 7 月 30 日在学校组织“夏令营”活动，请大家提前做好安排，有问题可以私信我。\n 我当场傻掉。\n双引号加得真的好啊！\n还有这个语气，并不是在征求意见嘛！\n妙啊！\n不就是成绩不如其他民办学校了吗？\n这只是一天两天的事情吗？难道是我们这一届太垃圾了吗？但是，以前就很厉害了吗？那么请问，为什么我们学校不敢宣传今年中考的成绩呢？\n我承认我们这一届摇号进来的占多数，比以前差了点。但我还是想请问一下敬爱的领导和老师们，你们有想过自己的问题吗？\n为什么我们比其他学校花的时间都要多，成绩却还是不如人呢？是我们学生还不够努力吗？\n我想不是。\n从入学到现在，已经过了一年了。现在再回望入学前对这所学校的憧憬、期待，我觉得很不可思议。\n现在，我校口碑已经大不如前了。如果敬爱的领导和老师们不及时悬崖勒马的话，你们就赚不了钱了！\n最后，我还是想重复开头的那句话。\n*** 你 * 什么时候 * 啊？\n 不管怎样，我还是很尊重带我们的各科老师。不可否认的是，你们都很有责任心，一直陪着我们加班。感谢你们！\n","date":"Jul 17","permalink":"https://blog.chungzh.cn/articles/ilovesmes/","tags":["随笔","学校"],"title":"我所热爱的，就是这所学校"},{"categories":null,"contents":"暑假来了，顺便把博客更新一下。\n从以前的 Vuepress 变成了 Hugo，速度真的快了很多，不愧是 \u0026ldquo;The world’s fastest\u0026rdquo;。用的主题是 Tania，很简洁、漂亮。Hugo 非常易用，不到半天就完整迁移过来了。我可以很肯定地说这一次博客迁移是有史以来最快的一次。\nCI 用的是 GitHub Actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  name:github pageson:push:branches:- hugo # Set a branch to deploypull_request:jobs:deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;# extended: true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_branch: master # default:gh-pages  总之就是非常丝滑，Hugo NB!\n","date":"Jul 16","permalink":"https://blog.chungzh.cn/articles/hello-hugo/","tags":["Blog","Hugo"],"title":"Hello Hugo!"},{"categories":null,"contents":" 他山之石，可以攻玉。\n    CSP-J1  入学你校几乎两个月都在搞初赛。\n结果初一还是只有两个人过了\n最后是 73.5 分，水过去了。\n    CSP-J2     Day 0  要去大学城的广大附中，就去住酒店了。\n在 tjl 大佬房间里 玩，其实是在看凤凰台。\n依稀记得那晚上拜登和特朗普的比分是 264 : 214，林郑去北京见韩正了。\nCCTV-7 上面中科院在帮农民种橘子？\n十点多就回去昏昏沉沉地睡了，还挺香（\n   Day 1  早上六点半就醒了。\n在酒店吃了顿自助早餐，真香。\n到处都是石实的大佬 %%% 。\n然后搭着同校热心家长的车前往广大附中。\n门口还挺热闹的，好像发生了许多事情：\n 黄老师身份证不见了，其实藏在袋子里 某大佬没带准考证 还有没带粤康码的  于是感到很庆幸，没入考场的时候也是一场考验。。所以说带齐资料很重要。\n很快就进考场了。\n电脑有 8G 内存，装的是 Windows 10 神州网信政府版，感觉只是开始菜单看上去稍有不同。\n下发题目之后几分钟我还在打 A+B，打完之后才一愣一愣地抄密码解压题目。\n翻了一下，发现第一题好难，于是从第二题开始做。\nT2 刚开始竟然用了 sort，到了最后试大样例的时候才看到一卡一卡的，于是又改成了插入排序，以为没问题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; bool cmp(int a, int b) { return a \u0026gt; b; } int a[100005]; int main() { int n, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); for (int i = 0; i \u0026lt; n; i++) { int inp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;inp); int j = 0; for (; j \u0026lt; i; j++) { if (a[j] \u0026lt; inp) break; } for (int k = i; k \u0026gt;= j; k--) { a[k+1] = a[k]; } a[j] = inp; int planNum = max(1, (int)((i+1)*0.01*w)); printf(\u0026#34;%d \u0026#34;, a[planNum-1]); } return 0; }   然后 T3 看了好久才弄懂，就暴力 stack 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  #include \u0026lt;iostream\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; int n; int a[100003]; int main() { string expr; getline(cin, expr); const int exprlen = expr.length(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; q; i++) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); a[t] = !a[t]; string cur; for (int j = 0; j \u0026lt; exprlen+1; j++) { if (j == exprlen || expr[j] == \u0026#39; \u0026#39;) { if (cur == \u0026#34;!\u0026#34;) { int t = s.top(); s.pop(); s.push(!t); } else if (cur == \u0026#34;\u0026amp;\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t \u0026amp;\u0026amp; t2); } else if (cur == \u0026#34;|\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t || t2); } else if (cur[0] == \u0026#39;x\u0026#39;) { int xb = 0; for (int k = 1; k \u0026lt; cur.length(); k++) { xb *= 10; xb += cur[k]-\u0026#39;0\u0026#39;; } s.push(a[xb]); } cur.clear(); } else cur += expr[j]; } printf(\u0026#34;%d\\n\u0026#34;, s.top()); if (!s.empty()) s.pop(); a[t] = !a[t]; } return 0; }   接下来才开始构思第一题，一直摸不着头绪，就随随便便写了一个爆搜，枚举 2 的幂相加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int n; const int a[23] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608}; int ansn = 0, ans[24]; int dfs(int step, int sum) { if (sum \u0026gt; n) return 0; if (step \u0026gt; 23) return 0; if (sum == n) { return 1; } for (int i = 1; i \u0026lt;= 22; i++) { int t1 = dfs(step+i, sum + a[step]); if (t1) { ans[ansn++] = a[step]; return 1; } } } int main() { cin \u0026gt;\u0026gt; n; if (n % 2 != 0) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } for (int i = 0; i \u0026lt; 23; i++) { if (n == a[i]) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; endl; return 0; } } dfs(0, 0);\tfor (int i = 0; i \u0026lt; ansn; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; }   第四题直接无脑爆搜，能拿到暴力分就 ok。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; long long ans = -99999999999; int a[1005][1005], n, m; bool vis[1005][1005]; const int dx[3] = { -1, 1, 0 }; const int dy[3] = { 0, 0, 1 }; void dfs(int x, int y, long long sum) { if (x == n \u0026amp;\u0026amp; y == m) { // 终点 \tans = max(ans, sum+a[x][y]); return ; } for (int i = 0; i \u0026lt; 3; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 1 || ny \u0026lt; 1 || nx \u0026gt; n || ny \u0026gt; m) continue; if (vis[nx][ny]) continue ; vis[nx][ny] = 1; dfs(nx, ny, sum + a[x][y]); vis[nx][ny] = 0; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); vis[i][j] = false; } } dfs(1, 1, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; }   出了考场之后和 tjl 对答案，才知道第一题考的是二进制，第二题要用桶排序。。。\n然后那时竟然还挺乐观的，觉得我的也没问题。。。\n甚至还开始讨论有没有 1= 。。。。。。。。。\n直到洛谷上了民间数据自测。\n100 + 80 + 30 + 15 = 225\n还是看看能不能有二等吧。。\n总之达到了考前的期望，考后还是太自信了一点点。也没什么遗憾，正常发挥出了自己的水平。\n那么就：\nCSP-J/S 2021 RP++\n UPD: 215 分，2=\n","date":"Nov 14","permalink":"https://blog.chungzh.cn/articles/csp-j-2020/","tags":["游记","信息学","CSP","CCF"],"title":"CSP-J 2020 游记"},{"categories":null,"contents":"   前言  最近开始学习 Qt，然后就挖坑了一个小玩具 Notepanda，顺便看看能不能替代诸如 notepad、gedit 之类的软件。顺便锻炼一下自己。\nGitHub repo\n   Feature   基本的文本编辑操作（没想到吧这也是 feature 了哈哈哈哈哈哈） 行号显示 语法高亮 从命令行启动。（如 notepanda 或者 notepanda CMakeLists.txt）  除此之外还实现了自定义字体、字号、Qt 主题和 Status Bar 等一些小功能。\n以后的目标是实现多标签页，并对 Markdown 做一点优化（比如预览），如果有可能还会加进去一个 terminal。计划在 GitHub Projects。\n目前还是很弱的一个东西，不过等查找、替换等 feature 实现之后，基本上可以替代 Windows 的 notepad 了。\n   Screenshots     实现  这部分大概讲讲思路吧。\n   布局     编辑控件  使用了 Qt 提供的 QPlainTextEdit 类，适合纯文本编辑。刚开始还用的是 QTextEdit，想想自己真是傻了，又不是要编辑富文本哈哈哈。\n不过 QPlainTextEdit 似乎有点点慢，我也没能力造轮子，于是就将就着用吧。\n   语法高亮  刚开始想实现的时候看见了 Qt 官方的 Syntax Highlighter Example，很棒对吧。但是我可不想花精力去写一堆语言的规则呢！\n然后就找到了 KDE Framework 里的 KSyntaxHighlighting。KDE Framework 是真的烦人，刚开始怎么也 build 不出来。等到了 GitHub Actions 上，整整用了四天时间才搞定，还是在某 Packman 的帮助下才完成的。。。当时看到绿绿的 Actions，我差点没开心得疯掉。。\n这个 KSyntaxHighlighting，deepin-editor 和 Qt Creator 都在使用。好在他自己也提供了一些 example，看上去很简单。依赖也很小，只有 Extra CMake Modules，不过看上去和高亮的功能没啥关系，也许是 KF 必备依赖吧。它自带了两百多种语言的高亮规则，省了我很多事情，有 Dark / Light 主题，不服还可以自己写。很满意。\n   CI  我可不想每次更新都自己打一次包，没那个闲心，手上能用的系统也不够 :) 穷孩子怎么买得起 Mac。所以只能用 CI 啦。\n现在 CI 主要帮我解决了：\n Windows 安装程序 Windows 上的 7z \u0026amp; MacOS 上的 dmg \u0026amp; Linux 的 AppImage Release 时自动上传以上所有文件  CI 平台当然是选择了 GitHub Actions 啦！现在这个项目所有环节都在 GitHub 上能找到，AUR 除外 :(\nNotepanda 的 CI 全都是抄 Qv2ray 上的，可真是帮了我很多忙。\n   最后  感谢 Qv2ray 的 Super Packman: ymshenyu，感谢死鬼 gcc，感谢鸭鸭，感谢 Qv2ray User Group 里面的每一个人。如果没有他们，我的 Qt 旅程不会这么顺利。\n顺便，Qv2ray 是一个很好用的 v2ray 跨平台客户端，欢迎尝试！\n谢谢阅读 🙇‍♂️\n最后，放上我画的一只小熊猫：\n  ","date":"May 16","permalink":"https://blog.chungzh.cn/articles/notepanda/","tags":["文本编辑器","Qt","C++","编程"],"title":"Notepanda 开发小结"},{"categories":null,"contents":" 在开始之前的一点闲话：当你看到这款应用的图标时，也许会联想到 Windows Terminal。打开后，甚至会发现连 UI 都有点相似。但事实上，这两款软件完全没有关系。Notepads 是由一位国人独立开发的。\n    介绍  Notepads 是一款美观且简洁的 UWP 文本编辑器，为代替 Notepad 而生。它没有代码高亮、丰富的插件或是酷炫的主题，因为他只是一款比 Notepad 更强的记事本。它没有 VS Code 或是 Sublime 的强大，就算是和 Notepad++ 比较，在代码编辑方面由于没有语法高亮也稍显逊色，但它依然是一款优秀的记事本，为编辑轻量文本而生的记事本。如果你只是想要快速浏览代码，写写注释，修改配置文件，或是写一段小短文，就应该使用 Notepads，而不是打开庞大的 VS Code，忍受漫长的加载时间。\nNotepads 使用了 Fluent Design，有亚克力背景，支持浅色和深色模式，很漂亮。即使是信奉「好看就是生产力」的我也爱上了这个软件。\n   特性  Notepads 有许多强大的特性：\n 支持多标签页（此处 cue 微软赶紧开发 Sets！） 轻便、快捷 多行手写支持 设置 Tab 长度、编码、换行符、字体及大小等  下面拿几个比较有用的特性单独讲讲：\n   Markdown 预览  Notepads 支持 Markdown 实时预览，但这并不意味着你可以用它来做主力 MD 编辑器。在这方面它依然是不合格的。\nNotepads 还支持在预览时替换 Emoji code 为 Emoji 噢:smiley:！\n   文件更改预览  Notepads 内置了 diff 查看器，可以很方便地对比新旧文件之间的差异。\n   终端中打开 Notepads  在终端中输入 notepads 或 notepads foo.bar 都可以唤出 Notepads。\n在 WSL 中，你也可以通过 powershell.exe -c notepads \u0026lt;filepath\u0026gt; 使用 Notepads 打开文件。\n   尾巴  Notepads 是一款 C# 开源软件，源码在 GitHub 。可在 Microsoft Store 查找 Notepads 即可下载。\n ","date":"Apr 06","permalink":"https://blog.chungzh.cn/articles/notepads/","tags":["UWP","文本编辑器","Windows10"],"title":"一款纯粹的 UWP 记事本——Notepads"},{"categories":null,"contents":"在开发中经常需要测量时间，比如性能优化时，比较两种方法的耗时。除此之外，获取当前的时间也可以用于初始化随机数生成器。而 C++ 提供了很种方法来获取时间。\n   标准库     std::time     定义  这个函数会返回一个距离 UTC 时间 1970 年 1 月 1 日 0:00 的秒数。\n头文件：\u0026lt;ctime\u0026gt;\n文档：std::time\n1  std::time_t time( std::time_t* arg );      用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;windows.h\u0026gt; #include \u0026lt;ctime\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { time_t res_1 = time(nullptr); Sleep(1000); // do some stuff...  time_t res_2 = time(nullptr); cout \u0026lt;\u0026lt; res_1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; asctime(localtime(\u0026amp;res_1)) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; res_2 - res_1 \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* 输出结果 1585457981 Sun Mar 29 12:59:41 2020 1s */      std::chrono::steady_clock::now     定义  返回表示当前时间的时间点。\n这个时钟是专门用来计算时间的间隔的。C++ 还提供了一个 system_clock，用于获取系统的时间。\n头文件：chrono\n文档：std::chrono::stadey_clock\n1 2  static std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; now() noexcept; // (C++11 起)      用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u0026lt;windows.h\u0026gt; #include \u0026lt;chrono\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { chrono::steady_clock::time_point start = chrono::steady_clock::now(); Sleep(1000); // do some stuff...  chrono::steady_clock::time_point end = chrono::steady_clock::now(); chrono::duration\u0026lt;double\u0026gt; ans = end - start; cout \u0026lt;\u0026lt; ans.count() \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1.01495s */      Windows     GetTickCount     定义  检测自系统启动以来经过的毫秒数，最多为 49.7 天。如果不够用，可以使用 GetTickCount64。\n文档：GetTickCount function\n1  DWORD GetTickCount();      用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;windows.h\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { DWORD start = GetTickCount(); Sleep(1000); // do some stuff...  DWORD end = GetTickCount(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /*输出： 1016ms */      GetTickCount64     定义  检测自系统启动以来经过的毫秒数。\n文档：GetTickCount64 function\n1  ULONGLONG GetTickCount64();      用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;windows.h\u0026gt;#include \u0026lt;iomanip\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { ULONGLONG start = GetTickCount64(); Sleep(1000); // do some stuff...  ULONGLONG end = GetTickCount64(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1015ms */      QueryPerformanceCounter     定义  检测性能计数器的当前值，该值是一个高分辨率（\u0026lt;1us）时间戳，可用于时间间隔测量。\n这个函数是一个「黑科技」，精度非常高，用起来也稍微麻烦一点点。\n文档：QueryPerformanceCounter function\n   用法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;windows.h\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { LARGE_INTEGER freq; QueryPerformanceFrequency(\u0026amp;freq); // 获取性能计数器的频率  LARGE_INTEGER start; QueryPerformanceCounter(\u0026amp;start); Sleep(1000); // do some stuff...  LARGE_INTEGER end; QueryPerformanceCounter(\u0026amp;end); double misTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000000.0); // 微秒  double milTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000.0); // 毫秒  double sTime = (end.QuadPart - start.QuadPart) / freq.QuadPart; // 秒  cout \u0026lt;\u0026lt; misTime \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; milTime \u0026lt;\u0026lt; \u0026#34; milliseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sTime \u0026lt;\u0026lt; \u0026#34; seconds\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1.00367e+06 microseconds 1003.67 milliseconds 1 seconds */    至此，本文共介绍了五种测量时间段的方法。\n作者很菜，如发现什么问题，请在评论区中指出。\n谢谢 🙇‍♂️\n   Reference    Kurt Guntheroth. Optimized C++: Proven Techniques for Heightened Performance\n  CppReference\n  Microsoft Docs\n   ","date":"Mar 29","permalink":"https://blog.chungzh.cn/articles/cpp-get-time/","tags":["C++","Windows","时间"],"title":"Windows 中 C++ 测量时间的 N 种方法"},{"categories":null,"contents":"   0x00 介绍 tabulate  tabulate 是一个使用 C++ 17 编写的库，它可以制作表格。使用它，把表格对齐、格式化和着色，不在话下！你甚至可以使用 tabulate，将你的表格导出为 Markdown 代码。下图是一个使用 tabulate 制作的表格输出在命令行的样例：\n当然，除了表格，你还可以玩出花样。看见下面这个马里奥了吗？这也是用 tabulate 制作的！源码在 这里。\n   0x10 准备  首先你需要安装 CMake。\n创建一个文件夹（下文用 X 代替），作为你使用 tabulate 的地方。再将 include 这个文件夹下载到 X 里。然后在 X 里创建 main.cpp 以及一个 CMakeLists.txt。\n 注意：需要下载 include 整个文件夹而不是仅仅下载 tabulate 文件夹\n你可以点击 这里 下载 tabulate 项目，然后将 include 文件夹复制到 X 中。\n 将下面的代码复制进 CMakeLists.txt ：\n1 2 3 4 5 6 7 8 9 10 11  cmake_minimum_required(VERSION 3.8)# 这里的 tabulateDemo 可以换为你喜欢的名字 project(tabulateDemo)set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED True)include_directories(include)add_executable(main main.cpp)  最后 X 文件夹的结构应该是这样的：\n1 2 3 4 5  . ├── CMakeLists.txt ├── include │ └── tabulate └── main.cpp    请认真核对好 X 的结构！\n 可前往 ChungZH/tabulatedemo 核对文件结构。\n   0x20 小试身手  将下面这段代码复制进 main.cpp 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026#34;tabulate/table.hpp\u0026#34;using namespace std; using namespace tabulate; int main() { Table hellogithub; // 创建一个叫做 hellogithub 的 Table 对象  hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; }     如果你使用的是 Linux/MacOS 系统，请在终端进入 X 文件夹并输入以下命令：\n1 2 3 4 5  mkdir build cd build cmake .. make ./main     如果你使用的是 Windows 系统和 MinGW，请检查是否安装 mingw32-make.exe，并在终端中进入 X 文件夹，输入：\n1 2 3 4 5  mkdir build cd build cmake .. mingw32-make ./main.exe     如果你使用 Windows 以及 MSVC，在终端中输入：\n1 2 3  mkdir build cd build cmake ..     然后使用 Visual Studio 打开 build 文件夹下的 tabulateDemo.sln 来运行。\n如果没有问题，那么你应该会在终端里看到：\n   0x30 格式化表格   请先认真分析 0x20 小试身手 章节中的代码并尝试着修改一下它！\n    0x31 Word Wrapping  为了防止表格中的内容过长导致不整齐，你可以指定表格每一列的宽度，tabulate 就会自动帮你换行。语法如下：\n1 2  // 将表格第 0 行第 0 列的宽度设为20 table[0][0].format().width(20);   除了自动换行，你也可以在内容中使用 \\n 来手动设置换行。\n这是一个 Word Wrapping 的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026#34;tabulate/table.hpp\u0026#34;using namespace std; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;This paragraph contains a veryveryveryveryveryverylong word. The long word will break and word wrap to the next line.\u0026#34;, \u0026#34;This paragraph \\nhas embedded \u0026#39;\\\\n\u0026#39; \\ncharacters and\\nwill break\\nexactly where\\nyou want it\\nto\\nbreak.\u0026#34;}); table[0][0].format().width(20); // 设置第 0 行第 0 列的宽度为 20  table[0][1].format().width(50); // 设置第 0 行第 1 列的宽度为 50  cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; endl; return 0; } return 0; }     第 0 行第 0 列的文字是不是很长？但是设置了它的宽度后，就不用担心了。tabulate 将会帮你自动换行。如果不设置的话，表格就会变得很不整齐，你也可以尝试一下。\n  第 0 行第 1 列的内容里运用了\\n 的换行符，所以即使我们给它设置了 50 的宽度，也会先根据内容里的 \\n 换行符来换行。\n  值得注意的是，tabulate 会自动删除每一行内容两边的空白字符。\n     0x32 字体对齐  tabulate 支持三种对齐设置：左、中和右。默认情况下，全部内容都会靠左对齐。\n要手动设置对齐方式，可以使用 .format().font_align(方向)。\n举一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026#34;tabulate/table.hpp\u0026#34;using namespace std; using namespace tabulate; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format() .font_align(FontAlign::center); // 设置居中对齐  hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_align(FontAlign::left); // 设置靠左对齐  hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_align(FontAlign::center); // 设置居中对齐  hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); hellogithub[3][0].format() .font_align(FontAlign::right); // 设置靠右对齐  hellogithub[0][0].format().width(50); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; }      0x33 字体样式  tabulate 支持以下八种字体样式：\n  粗体 bold\n  深色 dark\n  斜体 italic\n  下划线 underline\n  闪烁 blink （？）\n  翻转 reverse\n  隐藏 concealed\n  删除线 crossed\n   某些样式可能会因为终端的原因而无法显示。\n如：粗体、深色、斜体、闪烁等样式，请慎用。\n 要使用这些样式，可以调用 .format().font_style({...})。样式也可以叠加使用。\n   0x34 颜色  你可以对表格的字体、边框、角以及列分隔符号设置它们的前景或背景颜色。\ntabulate 支持 8 种颜色：\n  灰色 gray\n  红色 red\n  绿色 green\n  黄色 yellow\n  蓝色 blue\n  洋红色 magenta\n  青色 cyan\n  白色 white\n  可以通过 .format().\u0026amp;lt;element\u0026amp;gt;_color(颜色) 的方式定义前景色或通过 .format().\u0026amp;lt;element\u0026amp;gt;_background_color(颜色) 的方式定义背景色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026#34;tabulate/table.hpp\u0026#34;using namespace tabulate; using namespace std; int main() { Table colors; colors.add_row({\u0026#34;Font Color is Red\u0026#34;, \u0026#34;Font Color is Blue\u0026#34;, \u0026#34;Font Color is Green\u0026#34;}); colors.add_row({\u0026#34;Everything is Red\u0026#34;, \u0026#34;Everything is Blue\u0026#34;, \u0026#34;Everything is Green\u0026#34;}); colors.add_row({\u0026#34;Font Background is Red\u0026#34;, \u0026#34;Font Background is Blue\u0026#34;, \u0026#34;Font Background is Green\u0026#34;}); colors[0][0].format() .font_color(Color::red) .font_style({fonttyle::bold}); colors[0][1].format() .font_color(Color::blue) .font_style({fonttyle::bold}); colors[0][2].format() .font_color(Color::green) .font_style({fonttyle::bold}); colors[1][0].format() .border_left_color(Color::red) .border_left_background_color(Color::red) .font_background_color(Color::red) .font_color(Color::red); colors[1][1].format() .border_left_color(Color::blue) .border_left_background_color(Color::blue) .font_background_color(Color::blue) .font_color(Color::blue); colors[1][2].format() .border_left_color(Color::green) .border_left_background_color(Color::green) .font_background_color(Color::green) .font_color(Color::green) .border_right_color(Color::green) .border_right_background_color(Color::green); colors[2][0].format() .font_background_color(Color::red) .font_style({fonttyle::bold}); colors[2][1].format() .font_background_color(Color::blue) .font_style({fonttyle::bold}); colors[2][2].format() .font_background_color(Color::green) .font_style({fonttyle::bold}); cout \u0026lt;\u0026lt; colors \u0026lt;\u0026lt; endl; return 0; }      0x35 边框、角  你可以对表格的边框和角的文本、颜色或背景颜色进行自定义。\n你可以使用 .corner(..)、.corner_color(..) 和 corner_background_color(..) 来对所有的角设置一个共同的样式。你也可以使用 .border(..) 、.border_color(..) 和 .border_background_color(..) 来对所有的边框设置一个共同的样式。\n这是一个单独设定所有边框和角的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include \u0026lt;tabulate/table.hpp\u0026gt;using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;ᛏᚺᛁᛊ ᛁᛊ ᚨ ᛊᛏᛟᚱy ᛟᚠᚨ ᛒᛖᚨᚱ ᚨᚾᛞ\\n\u0026#34; \u0026#34;ᚨ ᚹᛟᛚᚠ, ᚹᚺᛟ ᚹᚨᚾᛞᛖᚱᛖᛞ ᛏᚺᛖ\\n\u0026#34; \u0026#34;ᚱᛖᚨᛚᛗᛊ ᚾᛁᚾᛖ ᛏᛟ ᚠᚢᛚᚠᛁᛚᛚ ᚨ ᛈᚱᛟᛗᛁᛊᛖ\\n\u0026#34; \u0026#34;ᛏᛟ ᛟᚾᛖ ᛒᛖᚠᛟᚱᛖ; ᛏᚺᛖy ᚹᚨᛚᚲ ᛏᚺᛖ\\n\u0026#34; \u0026#34;ᛏᚹᛁᛚᛁᚷᚺᛏ ᛈᚨᛏᚺ, ᛞᛖᛊᛏᛁᚾᛖᛞ ᛏᛟ\\n\u0026#34; \u0026#34;ᛞᛁᛊcᛟᚹᛖᚱ ᛏᚺᛖ ᛏᚱᚢᛏᚺ\\nᛏᚺᚨᛏ ᛁᛊ ᛏᛟ cᛟᛗᛖ.\u0026#34;}); table.format() .multi_byte_characters(true) // Font styling  .font_style({fonttyle::bold, fonttyle::dark}) .font_align(FontAlign::center) .font_color(Color::red) .font_background_color(Color::yellow) // Corners  .corner_top_left(\u0026#34;ᛰ\u0026#34;) .corner_top_right(\u0026#34;ᛯ\u0026#34;) .corner_bottom_left(\u0026#34;ᛮ\u0026#34;) .corner_bottom_right(\u0026#34;ᛸ\u0026#34;) .corner_top_left_color(Color::cyan) .corner_top_right_color(Color::yellow) .corner_bottom_left_color(Color::green) .corner_bottom_right_color(Color::red) // Borders  .border_top(\u0026#34;ᛜ\u0026#34;) .border_bottom(\u0026#34;ᛜ\u0026#34;) .border_left(\u0026#34;ᚿ\u0026#34;) .border_right(\u0026#34;ᛆ\u0026#34;) .border_left_color(Color::yellow) .border_right_color(Color::green) .border_top_color(Color::cyan) .border_bottom_color(Color::red); std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; return 0; }      0x36 基于范围的迭代  一个一个设置表格的样式是不是很麻烦？tabulate 提供了迭代器，支持对表、行和列的迭代，更方便地格式化表格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;tabulate/table.hpp\u0026gt;using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;Company\u0026#34;, \u0026#34;Contact\u0026#34;, \u0026#34;Country\u0026#34;}); table.add_row({\u0026#34;Alfreds Futterkiste\u0026#34;, \u0026#34;Maria Anders\u0026#34;, \u0026#34;Germany\u0026#34;}); table.add_row({\u0026#34;Centro comercial Moctezuma\u0026#34;, \u0026#34;Francisco Chang\u0026#34;, \u0026#34;Mexico\u0026#34;}); table.add_row({\u0026#34;Ernst Handel\u0026#34;, \u0026#34;Roland Mendel\u0026#34;, \u0026#34;Austria\u0026#34;}); table.add_row({\u0026#34;Island Trading\u0026#34;, \u0026#34;Helen Bennett\u0026#34;, \u0026#34;UK\u0026#34;}); table.add_row({\u0026#34;Laughing Bacchus Winecellars\u0026#34;, \u0026#34;Yoshi Tannamuri\u0026#34;, \u0026#34;Canada\u0026#34;}); table.add_row({\u0026#34;Magazzini Alimentari Riuniti\u0026#34;, \u0026#34;Giovanni Rovelli\u0026#34;, \u0026#34;Italy\u0026#34;}); // 设置每一行的宽度  table.column(0).format().width(40); table.column(1).format().width(30); table.column(2).format().width(30); // 遍历第一行中的单元格  for (auto\u0026amp; cell : table[0]) { cell.format() .font_style({fonttyle::underline}) .font_align(FontAlign::center); } // 遍历第一列中的单元格  for (auto\u0026amp; cell : table.column(0)) { if (cell.get_text() != \u0026#34;Company\u0026#34;) { cell.format() .font_align(FontAlign::right); } } // 遍历表格中的行  size_t index = 0; for (auto\u0026amp; row : table) { row.format() .font_style({fonttyle::bold}); // 轮流把整行的背景设为蓝色  if (index \u0026gt; 0 \u0026amp;\u0026amp; index % 2 == 0) { for (auto\u0026amp; cell : row) { cell.format() .font_background_color(Color::blue); } } index += 1; } std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; }      0x37 嵌套表格  在 tabulate 中嵌套表格很容易，因为 Table.add_row(...) 这个函数可以接受 std::string 类型和 tabulate::Table。下面是一个嵌套表格的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026#34;tabulate/table.hpp\u0026#34;using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0] .format() .font_background_color(Color::blue) .font_align(FontAlign::center); Table hglink; hglink.add_row({\u0026#34;GitHub repo\u0026#34;, \u0026#34;Website\u0026#34;}); hglink.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;, \u0026#34;hellogithub.com\u0026#34;}); hellogithub.add_row({hglink}); // 嵌套！  cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; }      0x40 导出     0x41 Markdown  可以使用 MarkdownExporter 来将一个表格导出为 GFM 风格的 Markdown。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include \u0026#34;tabulate/markdown_exporter.hpp\u0026#34; // 注意这个头文件#include \u0026#34;tabulate/table.hpp\u0026#34;using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format().font_style({fonttyle::bold}); // 加粗样式，在 Markdown 中可以表现出来  hellogithub.add_row({\u0026#34;GitHub repo: github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;Website: hellogithub.com\u0026#34;}); // 导出为 Markdown  MarkdownExporter exporter; auto markdown = exporter.dump(hellogithub); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Markdown Source:\\n\\n\u0026#34; \u0026lt;\u0026lt; markdown \u0026lt;\u0026lt; endl; return 0; }   导出效果如下：\n   HelloGitHub     GitHub repo: github.com/521xueweihan/HelloGitHub   Website: hellogithub.com     注意：Markdown 不能指定每一个单元格的对齐样式，只能指定一列的对齐样式，像这样 hg.column(1).format().font_align(FontAlign::center);。\n    0x50 尾声  如果想要更详细地了解 tabulate 的用法，请查看官方文档 https://github.com/p-ranav/tabulate 。\n本文是作者的第一次关于此类型文章的尝试，如有不足之处，请指正，谢谢！\n再见！\n ","date":"Feb 21","permalink":"https://blog.chungzh.cn/articles/tabulate/","tags":["C++"],"title":"优雅地使用 C++ 制作表格：tabulate"},{"categories":null,"contents":"   Detail    时间：2020/1/16 至 2020/1/20，共计 5 日。\n  地点：石门实验学校（太平新校区）\n  老师：czf、lzl\n     Day 1  新校区还是蛮气派的。\n竟然搞了一个开幕式，大佬 卢yq 上台讲话，还见到了金培星老师 %%%。\n然后还拍了一张大合照。\n不得不说老师还是很厉害的。\n   早上  讲了镇赛的 T5 和 T6，茅塞顿开。\nPDF link\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // DLOI T5 魔术数组 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int a[n][n]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[0][i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i][i]; if (n == 1) { cout \u0026lt;\u0026lt; a[0][0] \u0026lt;\u0026lt; endl; return 0; } // 前一行与后一行的所有数之间都有公差  int cha; for (int i = 1; i \u0026lt; n; i++) { cha = a[i-1][i]-a[i][i]; for (int j = 0; j \u0026lt; n; j++) a[i][j] = a[i-1][j] - cha; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // DLOI T6 三角形个数 // OnlineJudge: [Mr.Huang OJ] http://111.230.62.117/problem.php?id=1905 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; long long cnt = 0; for (int i = 0; i \u0026lt; n; i++) { long long l; cin \u0026gt;\u0026gt; l; if (l \u0026gt; 0) cnt++; // 负数不算  } // 排列  // 只要是正数都可组成三角形  // 求 从 n 个整数中取出 3 个数，有多少种排列方案  long long ans = cnt*(cnt-1)*(cnt-2)/6; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   然后去吃了一顿丰盛但不美味的午餐，感觉不值 ￥20。。。\n   下午  STL 专题开始。\n讲了 vector，基本上都会。\n清空 vector 还是第一次见，方法：\n1  vector\u0026lt;int\u0026gt;().swap(v); //清空v,并释放空间; 惯用法。      Day 2  主要考 set map queue 的应用，思考难度不是非常大。\n   早上  STL 专题之 set、map。\nNO.2 ~\n   下午  STL 专题之 queue。\nNO.1！\n应 rank 4 要求，顺带截了他的图。。\n   Day 3  二分。\n战况惨烈，不截图了。。\n以后还要恶补一下二分。\n   Day 4  宽搜。\n   Day 5     早上  结营考。\nrank 7。\n不太理想\n   下午  结营。\n获得优秀营员称号。\n   总结  先放一张朋友看到我结营照片时的点评。\n这几天过得很充实，也很累，学到了很多知识。\n近几天教育部也发了一个「强基计划」，对我们信息竞赛生影响很大。\n但，我还是会坚持下去的。\n","date":"Jan 20","permalink":"https://blog.chungzh.cn/articles/2020dlwintercamp/","tags":["游记","信息学"],"title":"2020 DL 信息学冬令营游记"},{"categories":null,"contents":" 嘤嘤嘤又被 dalao 狂虐了\n    赛前情况  自从上一次 NHOI 之后，就荒废了信息学，基本上没有刷题。原因很多，一是六年级的学业繁重，二是家里一度禁止我玩电脑（不能自律）。直到考前一个星期才练了练手，企图抱佛脚。\n所以我自己对这次比赛都没有什么信心，不要跌出一等奖线、能保住创新班名额就好了。\nmr.lgj 说过这次比赛会非常难，但是一定不要放弃。（意思就是说可以暴力骗分~\n就这样，我仓促地去比赛了。\n   比赛  是 2019/12/17 呢。\n   摸鱼时间  熟悉的沥中机房啊~\n考号是 XJ007，特工？\n监考老师穿着一件火影衣服呢真帅\n想打开 Luogu 看看运势，但是不敢上网。现在想想那天的运势一定很差叭。\n   比赛时间     8:20 发卷  拿到卷子之后浏览了一下，然后开始怀疑人生。mr.lgj 说得没错，这真是一次非常非常难的比赛，比上次区赛还要难很多很多很多。。。\n开始怀疑走错地方了。。\n这真的是小学甲组的镇赛吗。。。\n。。。\n   8:30 开考  T1 一眼看上去，凉了。大意是比较两个数的平方大小，20% 的数据这两个数都大于 10^8，竟然要搞高精，天哪完全没学过高精啊。。。于是草草暴力了就去水 T2。\nT2 是字符串模拟，5 min 搞掉。\n然后又看了看 T1，才发现比较两个数的平方的大小不就是比较两个数的大小吗？？？根本不用乘啊，我真是菜死了/kk\n然后 T3 晕乎乎的，是道模拟。一眼看上去就很麻烦，最后打了个自己的看不懂的代码，能水样例就行了吧。\n于是到了 9:06，开始搞 T4。其实是很简单的一道题，赛后发现自己写得太麻烦了而且还是错的。。。有点可惜。\n9:58 开始就骗 T5 T6 的部分分了，分别骗了 50 和 70 分。\n到了最后觉得太累了，脑子转不动了。。我太南了。\n   赛后总结    T1：模拟\n  T2：字符串 模拟\n  T3：模拟\n  T4：贪心\n  T5：找规律\n  T6：数学\n  难度：T1\u0026lt;T2\u0026lt;T4\u0026lt;T3\u0026lt;T5\u0026lt;T6。\n我死了。\n然后学校里的信息队就停训了，那周的少年宫也是最后一次了。这学期剩下的时间都要搞文化课了。\n估计三四百分吧，能混个 1= 就行，不要求太高了。\n总的来说还是有点可惜，特别是 T4。\n那么，OI 再见，文化课你好！\n下周大概就出分了，到时候再来更新吧\nupd：分数出了，470 分，rank 9。\n","date":"Dec 22","permalink":"https://blog.chungzh.cn/articles/dloi-2019/","tags":["游记","信息学"],"title":"DLOI 2019 游记"},{"categories":null,"contents":"包管理器可以帮助你更方便地安装依赖关系，并决定所安装的版本，提高你的开发幸福感。许多语言都有自己的包管理器，像 Node.js 的 npm/yarn、Rust 的 Cargo、Python 的 pip 等等。当然，C/C++ 也有它自己的包管理器！\n   1. Conan（C/C\u0026#43;\u0026#43; Package Manager）   官网：https://conan.io/ GitHub 项目地址：https://github.com/conan-io/conan Stars 数：3k 文档：https://docs.conan.io/en/latest/  首先出场的是 Conan（注意，不是柯南！），一个用 Python 编写的 C/C++ 包管理器。它是完全分散的，你可以自己托管服务器中的包。它适用于所有平台，包括 Linux、OS X、Windows、Solaris、FreeBSD、嵌入式和交叉编译、docker、WSL。它可以与任何构建系统集成，为 CMake、MSBuild、Makefiles 等工具提供了经过测试的支持。除此之外，它还获得了奔驰、华为等大公司用户。你还可以在 Conan-Center 寻找或分享你的 C/C++ 包。\n想要安装 Conan 也很简单：\n1  $ pip install conan      2.Buckaroo   官网：https://buckaroo.pm/ GitHub 项目地址：https://github.com/LoopPerfect/buckaroo Stars 数：600 文档：https://github.com/LoopPerfect/buckaroo/wiki  这个 C++ 包管理器是使用 F# 语言开发的。它的独特之处就是直接从 GitHub、BitBucket、GitLab、托管的 Git 和 HTTP 中提取依赖项。同样的，它也是完全分散的，没有中央服务器。Buckaroo 使用 TOML 配置文件。\n它的工作流大概是这样的：\n1 2 3 4 5 6 7 8  # Create your project file $ buckaroo init # Install dependencies $ buckaroo add github.com/buckaroo-pm/boost-thread@branch=master # Run your code $ buck run :my-app   安装方法详见 Quick Install。\n   3.vcpkg   GitHub 项目地址：https://github.com/microsoft/vcpkg Stars 数：6k 文档：https://vcpkg.readthedocs.io/  vcpkg 是由微软爸爸开发的支持 Windows、Linux、Mac OS 的 C++ 库管理器，解决了 Windows 下常用依赖包的管理问题！它方便与 Visual Studio 集成，你可以使用 vcpkg search 搜索可用的包。它也可以从 Bitbucket、GitHub、GitLab 等获取包。\n安装方法详见 Quick Start。\n   4.Hunter   GitHub 项目地址：https://github.com/ruslo/hunter Stars 数：2k 文档：https://docs.hunter.sh 包：https://docs.hunter.sh/en/latest/packages.html  用于 C/C++ 的跨平台包管理器。支持 Linux、Windows、macOS、iOS、Android、Raspberry Pi 等平台。Hunter 主要用于管理带有 CMake 构建系统的软件包，现有的 CMake 软件包可以很容易地集成到系统中，但是使用带有 ExternalProject_Add 命令的自定义模板（构建方案）也支持非 CMake 软件包。\n注意：现在 Hunter 的 To be or not to be 已经成了问题，详见 Issue #1921。如果它在 https://patreon.com/ruslo 上没有得到足够的支持，维护者将会在 2019 年 8 月 25 日停止维护该项目。请谨慎使用！\n开源不易，是人都要恰饭这个项目从 2013 年到现在，已经非常不易，目前已有 2k stars 了。大家可以给他 sponsor，让他继续走下去！\n   5.clib   GitHub 项目地址：https://github.com/clibs/clib Stars 数：3k 文档：https://github.com/clibs/clib/wiki 包：https://github.com/clibs/clib/wiki/Packages  clib 是一个 C 包管理器（非 C++），使用起来较简单。同样的，它也可以直接从 GitHub 上安装库。类似于 Node.js，它也是用 package.json 管理的。下面是一个例子：\n1 2 3 4 5 6 7 8 9  { \u0026#34;name\u0026#34;: \u0026#34;term\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;clibs/term\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Terminal ansi escape goodies\u0026#34;, \u0026#34;keywords\u0026#34;: [\u0026#34;terminal\u0026#34;, \u0026#34;term\u0026#34;, \u0026#34;tty\u0026#34;, \u0026#34;ansi\u0026#34;, \u0026#34;escape\u0026#34;, \u0026#34;colors\u0026#34;, \u0026#34;console\u0026#34;], \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;src/term.c\u0026#34;, \u0026#34;src/term.h\u0026#34;] }      6.poac   GitHub 项目地址：https://github.com/poacpm/poac Stars 数：341 官网：https://poac.pm/ 文档：https://doc.poac.pm/en/ 包：https://poac.pm/packages  别看 poac 现在 stars 数量少，它其实很适合新手使用。poac 具有直观且易于使用的界面（像 npm 和 Cargo一样）。独特的是，你可以在不了解 CMake 的情况下使用 poac 开发应用程序和库，专注于学习 C++ 而不会绊倒。作者还计划实现与其他构建系统和包管理器的集成，让你能够无缝切换。\n安装也是一行命令搞定：\n1  curl -fsSL https://sh.poac.pm | bash    ","date":"Aug 25","permalink":"https://blog.chungzh.cn/articles/c-cpp-package-manager/","tags":["C++","包管理器"],"title":"谁说 C/C++ 没有好的包管理器？这里来一沓！"},{"categories":null,"contents":" NHOI：南海区青少年信息学竞赛。\n    Day -1  日常颓废，用心思考如何提高人品。希望能拿到前 50 名。\n上次是五十开外，总要有点进步才行啊。\n不过要去到好的中学，五十名内可能也还不够吧。。\n不管怎样，努力吧，不想留下遗憾！\n   Day 1  今天很早就起床了。早上吃了一根香肠和一个荷包蛋，很香。状态也很好。\n进考场之后开始颓废小恐龙。。。\n对了，监考老师有一个很漂亮的小姐姐。。。\n本来还想睡一会儿觉，最后还是忍不住两边赛友的小恐龙的诱惑。。。\n然后很惊喜的发现，沥中的电脑竟然都有音响？！\n 8:23 Contest Start！\nT1 是一道简单蛇形矩阵，很快就肝掉了。\n然后看了看 T2，好像是模拟分数加减法，感觉约分、通分有点麻烦就先跳过去做 T3 了。\nT3 是啥我也忘了，反正 4 分钟就肝掉了。。\n继续看 T4，我觉得还是滚远点比较好。继续看 T5，感觉不太可做，就先溜了。\n回去 T2 打了一个短除法的 gcd（谁让我不会辗转相除法呢）和 lcm，花了半个小时（其实大多数时间都是在窥屏隔壁玩小恐龙的2333）就肝掉了。\n走过去看 T6，我肝！一个贪心肝掉了。（Bessie Cow 好评）\n继续滚回去 T4，觉得很难。这种题目以前的话，超时超掉一半分也算正常。然后继续苦思冥想。。。\n然后就想到了桶排序的思想，艰难地打了出来。。\n长呼一口气，颓颓小恐龙！（我可能是忘记了还有 T5 没做\n颓着颓着就和隔壁沥北小学的老哥聊上了。\n最后在 9:52 的时候非常暴力地怒切掉了 T5！做完了！\n于是开始快乐地玩耍\u0026hellip;\n发现电脑的 CPU 是 Intel Core i3-6100 CPU @ 3.70GHz。。海星吧\n然后右边的老哥又画了一个 九勾玉轮回眼 和 三勾玉写轮眼！\n哦对，小恐龙还颓到了 1750！\n比赛结束前十分钟非常紧张，一遍又一遍地检查文件读写有没有错、该开的 long long 有没有开······快疯了。\n 个人感觉难度 T1 \u0026lt; T2 \u0026lt; T3 \u0026lt; T5 \u0026lt; T4 \u0026lt; T6 ，估分 50 + 50 + 50 + 40 + 40 + 40 吧。\n 分数到 Day 2 下午就出了，50 + 50 + 50 + 50 + 40 + 40 = 280，rank 35，五年级 rk 10，非常满意！\n那么，NHOI 2019 再见，NHOI 2020 你好！\n","date":"Jun 02","permalink":"https://blog.chungzh.cn/articles/nhoi-2019/","tags":["游记","信息学"],"title":"NHOI 2019 游记"},{"categories":null,"contents":" Vuepress 是 Evan You 编写的一个 Vue 驱动的静态网站生成器，一般用于创建文档网站、博客网站。\n Vuepress 官方文档网站 · Vuepress GitHub 仓库地址 · awesome-vuepress 关于 Vuepress 的一些好东西\n本文将主要介绍创建 Vuepress 网站、使用 Git 管理、使用 CI 等方面的内容。\n 提示：我使用的是 Windows 系统，在其他平台上终端命令可能略有不同，请自行变通！\n    前期准备  请事先安装好 yarn、Git 等软件。本文不介绍安装这些前期准备的方法，请自行查阅文档，锻炼阅读文档能力。\n   下载 Vuepress  首先我们创建一个文件夹，用于存放 Vuepress。\n1 2  mkdir vuepress-blog cd vuepress-blog   然后往里面安装 Vuepress：\n1  yarn add vuepress@next # 安装 Vuepress 1.x 版本   再修改一下 package.json，添加以下内容：\n1 2 3 4  \u0026#34;scripts\u0026#34;: { \u0026#34;blog:dev\u0026#34;: \u0026#34;vuepress dev docs\u0026#34;, \u0026#34;blog:build\u0026#34;: \u0026#34;vuepress build docs\u0026#34; }      安装主题  Vuepress 的主题有很多，可以在 awesome-vuepress 关于 Vuepress 的一些好东西 挑选一个你喜欢的主题，或者直接在 GitHub 搜索也可以。这里我使用 vuepress-theme-meteorlxy 作为例子。\n1  yarn add vuepress-theme-meteorlxy@next   ok，现在你已经安装好主题了。\n   熟悉 Vuepress 目录结构  . ├── docs │ ├── .vuepress (可选的) │ │ ├── components (可选的) │ │ ├── theme (可选的) │ │ │ └── Layout.vue │ │ ├── public (可选的) │ │ ├── styles (可选的) │ │ │ ├── index.styl │ │ │ └── palette.styl │ │ ├── config.js (可选的) │ │ └── enhanceApp.js (可选的) │ │ │ ├── README.md │ ├── guide │ │ └── README.md │ └── config.md │ └── package.json  docs/.vuepress: 用于存放全局的配置、组件、静态资源等。 docs/.vuepress/components: 该目录中的 Vue 组件将会被自动注册为全局组件。 docs/.vuepress/theme: 用于存放本地主题。 docs/.vuepress/styles: 用于存放样式相关的文件。 docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。 docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。 docs/.vuepress/public: 静态资源目录。 docs/.vuepress/config.js: 配置文件的入口文件，也可以是 YML 或 toml。  大概就是这些，还有一些更高级的配置这里就没写了。相信有兴趣做更高级自定义的话都会自己去看 Vuepress 官方文档网站 了~\n   配置 Vuepress  首先创建 docs 目录、docs/.vuepress 目录：\n1 2  mkdir docs mkdir docs/.vuepress   然后进入 .vuepress 文件夹，创建一个 config.js 配置文件。\n在 config.js 中粘贴以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115  // .vuepress/config.js  module.exports = { // 网站 Title  title: \u0026#39;My Blog\u0026#39;, // 网站描述  description: \u0026#39;This is my blog\u0026#39;, // 网站语言  locales: { \u0026#39;/\u0026#39;: { lang: \u0026#39;zh-CN\u0026#39;, }, }, // 使用的主题  theme: \u0026#39;vuepress-theme-meteorlxy\u0026#39;, // 主题配置  themeConfig: { // 个人信息（没有或不想设置的，删掉对应字段即可）  personalInfo: { // 昵称  nickname: \u0026#39;meteorlxy\u0026#39;, // 个人简介  description: \u0026#39;Happy Coding\u0026lt;br/\u0026gt;Happy Life\u0026#39;, // 电子邮箱  email: \u0026#39;meteor.lxy@foxmail.com\u0026#39;, // 所在地  location: \u0026#39;Xi\\\u0026#39;an City, China\u0026#39;, // 组织  organization: \u0026#39;Xi\\\u0026#39;an Jiao Tong University\u0026#39;, // 头像  avatar: \u0026#39;https://www.meteorlxy.cn/assets/img/avatar.jpg\u0026#39;, // 社交平台帐号信息  sns: { // Github 帐号和链接  github: { account: \u0026#39;meteorlxy\u0026#39;, link: \u0026#39;https://github.com/meteorlxy\u0026#39;, }, // Facebook 帐号和链接  facebook: { account: \u0026#39;meteorlxy.cn\u0026#39;, link: \u0026#39;https://www.facebook.com/meteorlxy.cn\u0026#39;, }, // LinkedIn 帐号和链接  linkedin: { account: \u0026#39;meteorlxy\u0026#39;, link: \u0026#39;http://www.linkedin.com/in/meteorlxy\u0026#39;, }, // Twitter 帐号和链接  twitter: { account: \u0026#39;meteorlxy_cn\u0026#39;, link: \u0026#39;https://twitter.com/meteorlxy_cn\u0026#39;, }, // 新浪微博 帐号和链接  weibo: { account: \u0026#39;@焦炭君_Meteor\u0026#39;, link: \u0026#39;https://weibo.com/u/2039655434\u0026#39;, }, // 知乎 帐号和链接  zhihu: { account: \u0026#39;meteorlxy.cn\u0026#39;, link: \u0026#39;https://www.zhihu.com/people/meteorlxy.cn\u0026#39;, }, // 豆瓣 帐号和链接  douban: { account: \u0026#39;159342708\u0026#39;, link: \u0026#39;https://www.douban.com/people/159342708\u0026#39;, }, }, }, // 上方 header 的背景，可以使用图片，或者随机变化的图案  headerBackground: { // 使用图片的 URL，如果设置了图片 URL，则不会生成随机变化的图案，下面的 useGeo 将失效  url: \u0026#39;/assets/img/bg.jpg\u0026#39;, // 使用随机变化的图案，如果设置为 false，且没有设置图片 URL，将显示为纯色背景  useGeo: true, }, // 是否显示文章的最近更新时间  lastUpdated: true, // 顶部导航栏内容  nav: [ { text: \u0026#39;Home\u0026#39;, link: \u0026#39;/\u0026#39;, exact: true }, { text: \u0026#39;Posts\u0026#39;, link: \u0026#39;/posts/\u0026#39;, exact: false }, ], // 评论配置，参考下方 [页面评论] 章节  comments: { owner: \u0026#39;meteorlxy\u0026#39;, repo: \u0026#39;vuepress-theme-meteorlxy\u0026#39;, clientId: \u0026#39;MY_CLIENT_ID\u0026#39;, clientSecret: \u0026#39;MY_CLIENT_SECRET\u0026#39;, }, }, }    注意：这是 meteorlxy 主题的默认配置，其他主题请查看主题文档。\n 然后直接按照 meteorlxy 主题文档进行配置即可。\n   配置 CI 和 Git   持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。\n 👷 这里我们所使用的持续集成平台是 Travis CI.\n   开启 CI  首先，在 Create a new repository 里创建一个项目，项目名是 GitHub 用户名.github.io，然后到 Travis CI 官网，用 GitHub 账户直接关联登录，并允许 Travis CI 查看自己的公有仓库。\n然后我们到 Travis CI 账户页面开启博客仓库的 CI，如图：\n   添加变量  我们要设置三个变量：GIT_NAME、GIT_EMAIL、GITHUB_TOKEN，分别是 git 用户名、git 用户邮箱和 GitHub token。\n其中前两项的值可以在本地查看：\n1 2  git config --global user.name # 对应 GIT_NAME git config --global user.email # 对应 GIT_EMAIL   第三项 GitHub token 要在 GitHub 申请：\n 访问 GitHub 账户设置 \u0026gt; Tokens 生成新 Token: Generate new token 填入 Token 描述，并给予 Token 第一项 repo 的全部权限 将生成的 Token 复制，保存（生成 Token 的页面只有一次机会看见，请保存妥当。）  在 Travis CI 仓库配置中，将三个变量填入设置（位于 Settings \u0026gt; Environment Variables 处并保存：\n然后在博客根目录里创建一个 .travis.yml，并粘贴一下内容进去：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  language:node_jssudo:requirednode_js:\u0026#39;10\u0026#39;branches:only:- vuepressbefore_install:- export TZ=\u0026#39;Asia/Shanghai\u0026#39;install:- yarn installscript:- yarn blog:build- echo \u0026#34;chungzh.cn\u0026#34; \u0026gt; docs/.vuepress/dist/CNAME# 这里 \u0026#34;chungzh.cn\u0026#34; 改成你自己的域名，如果没有，删掉这行就行了deploy:provider:pagesskip_cleanup:truegithub_token:$GITHUB_TOKENlocal_dir:docs/.vuepress/distname:$GIT_NAMEemail:$GIT_EMAILkeep-history:truetarget-branch:masteron:branch:vuepress  然后我们新建一个 .gititnore 文件，粘贴以下内容：\n.DS_Store Thumbs.db db.json *.log node_modules/ docs/.vuepress/dist/ 好，现在输入以下命令，创建一个 Git 项目：\n1 2 3 4 5 6  git init git checkout -b vuepress git add . git commit -m \u0026#34;:tada: Init repo\u0026#34; git remote add origin git@github.com:ChungZH/ChungZH.github.io.git # 这里改成你自己的项目地址 git push -u origin vuepress   push 上去后，CI 应该就会开始了。静待片刻即可。\n ChungZH\n2019 - 3 - 2 / 广东 - 佛山\n#EOF 😘\n","date":"Mar 02","permalink":"https://blog.chungzh.cn/articles/create-vuepress-blog-and-use-git-manger-it/","tags":["Vuepress","Git","Blog"],"title":"创建 Vuepress 博客并使用 Git 管理"},{"categories":null,"contents":"Powershell 源代码仓库🔗 🎉🎉🎉Powershell/Powershell\n   前言  众所周知，Powershell 是微软开发的新一代的 shell。在微软的大力扶植下，已经成长为了一个成熟的 shell。而大部分人为了解决终端丑的问题，都选择了使用 Linux shell 这条路。而 WSL 的推出更促进了这一点。\n虽然使用 Linux shell 是一个不错的选择，但我们也可以在 Windows 的 shell 上下功夫。\n对了，为什么不是美化 CMD 呢？答案很简单，微软都抛弃的东西，我们还是也抛弃了吧。\n   开始  默认的 Powershell 是这样的：\n但我们要把它改成这样：\nwow~简直能和使用 oh-my-zsh 的终端媲美了！！！\n话不多说，咱们开始。\n首先我们了解一个工具 🌟oh-my-posh。关于它的介绍可以看我在即刻的推荐文。总之，这个工具就是用来美化 Powershell 的。上图就是用了 oh-my-posh 后的效果。\n   预备  为了获得更完美的体验，我们可以先安装几个 Powerline 字体。可以在 powerline/font 中下载。下载过程不赘述。\n下载好 Powerline 字体后，需要把终端的字体改成你刚刚下载的 Powerline 字体。\n对了，由于默认的 Powershell 终端改字体比较麻烦，我们可以使用终端模拟器。大家可以使用 Eugeny/terminus 这个工具。安装好后在 Settings 页面修改字体就行了。大家可以自己摸索。\n   安装  好了，先来安装一下 oh-my-posh。往 Powershell 狂输以下命令：\n1 2  Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser   这样就安装好了 posh-git 和 oh-my-posh 这两个插件了。\n   使用  1 2  Import-Module oh-my-posh Import-Module posh-git   输入如上命令即可。\n upd：oh-my-posh 默认提供了许多主题，大家可以自行切换。方法是：Set-Theme 主题名。主题有这些。大家可以自己玩玩。\n 好了，取得了这样的成果，或许你以为已经成功了。但是——你只要重启一次终端，你就会发现问题了。\n为什么重启之后终端又复原了呢？？？\n这是因为打开的时候必须要输入 Import-Module 那两行命令才能启用插件。\n那么我们可以设置一个脚本，让他每次打开 Powershell 就自动输入那两行命令。\n好了，明确了目标，我们就开始行动吧。\n首先输入：\n1  New-Item $profile   好了，打开这个文件——相信大家如果仔细看信息就能发现这个文件在哪里了。然后在这个文件中粘贴以下命令：\nImport-Module oh-my-posh Import-Module posh-git 就可以每次打开 Powershell 都自动用上 oh-my-posh 了。\nEnjoy it ☕~\n ","date":"Feb 23","permalink":"https://blog.chungzh.cn/articles/beautify-your-powershell/","tags":["Powershell","终端"],"title":"美化你的 Powershell"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.chungzh.cn/articles/","tags":null,"title":"Articles"},{"categories":null,"contents":"   我  就是个菜鸡。\n今年初二。\n   关于本站  本站使用 Hugo 搭建。详见： GitHub: ChungZH.github.io。\n如无特殊说明，本站的内容均使用 CC BY-NC-SA 2.5 协议。\n","date":"Jan 01","permalink":"https://blog.chungzh.cn/about/","tags":null,"title":"关于"},{"categories":null,"contents":"欢迎加友链哦！先友后链~\n有意者欢迎前往 GitHub - ChungZH.github.io 提交一个 PR，在本页面加上你的链接。或者发邮件给我也是可以的哦！邮箱是：chungzh07[AT]gmail.com。\n Koufan keithxodoy 泫 大尾巴苏卡卡的有底洞 GogesL zzzmh JunzhouLiu j0ck1e Alliot\u0026rsquo;s blog CareyQ Zidone Yi-yun Alpha1022 Vigorous Pro 左手的世界 PRIN BLOG Artin\u0026rsquo;s Blog EpLiar Coelacanthus Louis Aeilot\u0026rsquo;s blog Molink Eritque arcus     收藏夹 \u0026lt;del\u0026gt;单向恋\u0026lt;/del\u0026gt;   Spencer Woo  ","date":"Jan 01","permalink":"https://blog.chungzh.cn/friends/","tags":null,"title":"友链"}]