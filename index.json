[{"categories":"学习笔记","contents":"点分治，外国人称之为 Centroid decomposition，重心分解。\n何为树的重心 学习重心分解之前，自然要先了解重心。\n下面统一用 $n$ 表示树上结点的个数。\n在一棵树中，如果删除一个顶点后得到的最大子树的顶点数最少，那么这个点就是树的重心（Centroid）。\n重心的性质：\n删除重心后得到的所有子树，其顶点数必然不超过 $n/2$。\n证明：选取任意顶点作为起点，每次都沿着边向最大子树的方向移动，最终一定会到达某个顶点，将其删除后得到的所有子树的顶点数都不超过 $n/2$。如果这样的点存在的话，那么也就可以证明删除重心后得到的所有子树的顶点数都不超过 $n/2$。\n记当前顶点为 $v$，如果顶点 $v$ 已经满足上述条件则停止。否则，与顶点 $v$ 邻接的某个子树的顶点数必然大于 $n/2$。假设顶点 $v$ 与该子树中的顶点 $w$ 邻接，那么我们就把顶点 $w$ 作为新的顶点 $v$。不断重复这一步骤，必然会在有限步停止。这是因为对于移动中所用的边 $(v, w)$，必有 $v$ 侧的子树的顶点数小于 $n/2$，$w$ 侧的子树的顶点数大于 $n/2$，所以不可能再从 $w$ 移动到 $v$。因而该操作永远不会回到已经经过的顶点，而顶点数又是有限的，所以算法必然在有限步终止。\n树中所有顶点到某个顶点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。\n把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。\n在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。\n更多证明请见：树的重心的性质及其证明 - suxxsfe - 博客园 (cnblogs.com)\n寻找树的重心 根据重心的定义，先以 $1$ 为根进行 DFS。在递归中计算子树大小 $siz[u]$，并求出最大的子树的大小 $maxs[u]$，比较出重心 $centroid$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void getCentroid(int u, int fa, int s) { siz[u] = 1; maxs[u] = 0; for (int i = head[u]; i != 0; i = nxt[i]) { if (to[i] == fa) continue; getCentroid(to[i], u, s); siz[u] += siz[to[i]]; maxs[u] = max(maxs[u], siz[to[i]]); } // “向上” 的部分也是该结点的子树 maxs[u] = max(maxs[u], s - siz[u]); if (maxs[u] \u0026lt; maxs[centroid] || !centroid) centroid = u; } int main() { centroid = 0; getCentroid(1, 0, n); return 0; } 提交：CSES - Finding a Centroid\n点分治 我们可以用点分治解决关于统计树上路径的问题。\n例一 Luogu P3806【模板】点分治 1：给定一棵有 $n$ 个点的带边权树，$m$ 次询问，每次询问给出 $k$，询问树上距离为 $k$ 的点对是否存在。\n$n\\le 10000,m\\le 100,k\\le 10000000$\n暴力的做法至少需要 $O(n^{2})$，显然会超时，所以考虑分治。\n如何分割呢？如果随意选择顶点的话，递归的深度可能退化成 $O(n)$。若我们每次选择子树的重心作为新的根结点，可以让递归的层数最少。因为每次树的大小至少减半，所以递归的深度是 $O(log n)$。\n设当前的根结点是 $rt$。\n对于每一条路径 $(u, v)$，必然满足以下三种情况之一：\n顶点 $u, v$ 在 $rt$ 的同一子树内。 顶点 $u, v$ 分别在 $rt$ 的不同子树内。 顶点 $u, v$ 其中一个是 $rt$。 对于第 (1) 种情况，可以递归后转化成另外的情况。对于第 (2) 种情况，从顶点 $u$ 到顶点 $v$ 的路径必然经过根结点 $rt$，只要求出每个顶点到 $rt$ 的距离，就可以统计出答案。对于第 (3) 种情况，可以添加一个到 $rt$ 距离为 $0$ 的顶点，就转化为了第 (2) 种情况。\n需要注意的是，在第 (1) 种情况中统计的同一子树的顶点对，要避免在第 (2) 种情况中被重复统计。通过容斥和类似于树上背包的方法可以去重。\n最后的时间复杂度是 $O(nlog^{2}n)$。\nRECORD。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 int n, m; int L, p; int centroid; bool vis[MAXN], cnt[MAXW], ans[MAXM]; int ask[MAXM]; vector\u0026lt; std::pair\u0026lt; int, int \u0026gt; \u0026gt; g[MAXN]; int dis[MAXN]; int siz[MAXN], maxs[MAXN]; void getCentroid(int u, int fa, int s) { siz[u] = 1; maxs[u] = 0; for (auto i : g[u]) { if (i.first == fa || vis[i.first]) continue; getCentroid(i.first, u, s); siz[u] += siz[i.first]; maxs[u] = std::max(maxs[u], siz[i.first]); } maxs[u] = std::max(maxs[u], s - siz[u]); if (maxs[u] \u0026lt; maxs[centroid] || !centroid) centroid = u; } // 获取子树中所有点到重心的距离 void getDis(int u, int fa, int d) { dis[p++] = d; for (auto i : g[u]) { if (i.first == fa || vis[i.first]) continue; getDis(i.first, u, d + i.second); } } void calc() { L = p = 0; cnt[0] = 1; // 类似于树上背包 for (auto i : g[centroid]) { if (vis[i.first]) continue; getDis(i.first, centroid, i.second); // 一棵一棵子树合并，不会重复统计 for (int i = L; i \u0026lt; p; i++) { for (int j = 0; j \u0026lt; m; j++) { if (dis[i] \u0026gt; ask[j]) continue; ans[j] |= cnt[ask[j] - dis[i]]; } } for (int j = L; j \u0026lt; p; j++) cnt[dis[j]] = 1; L = p; } // 还原 cnt 数组 for (int i = 0; i \u0026lt; p; i++) cnt[dis[i]] = 0; // 不能用 memset } void solve(int u, int size) { centroid = 0; getCentroid(u, -1, size); getCentroid(centroid, -1, size); // 再求一次 siz，防止后面找重心时出错 vis[centroid] = true; calc(); for (auto i : g[centroid]) { if (vis[i.first]) continue; solve(i.first, siz[i.first]); } } int main() { solve(1, n); for (int i = 0; i \u0026lt; m; i++) { if (ans[i]) cout \u0026lt;\u0026lt; \u0026#34;AYE\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NAY\\n\u0026#34;; } return 0; } 需要注意的细节：\n分治的时候求出新的重心之后，也要再次求子树 $siz$。\n详见：一种基于错误的寻找重心方法的点分治的复杂度分析 - 博客 - liu_cheng_ao的博客 (uoj.ac)\n账号 920848348 评论：\n对于大部分点分治的代码中，不能直接 size = siz[v]，否则会导致后面的重心求错（可以用下面的样例试一下，然后输出重心节点看一下，你会发现从 $6$-\u0026gt;$3$ 这一大块的重心应该是 $2$，而代码输出是 $1$。原因在于：\n由于一开始从 点 $1$ 开始找整棵树的重心，此时的 $siz[u]$ 表示的仅仅是以 1 为根结点的树中，$u$ 的子树大小。那么现在重心 $root$ 找到了，那么从这整棵树的重心 $root$ 开始深搜时，若有边 $root$-\u0026gt;$v$ ，而此时的 $siz[v]$ 的值并不是以 $v$ 为根的子树的大小（这个子树当然不包括父亲 $root$ 那一块）。具体为什么，这里给一组样例，大家可以在图中画一下。 此样例的对应题目为 Luogu P3806【模板】点分治 1。\n然后我们一步一步来：\n先从 $1$ 开始 dfs ，统计 $siz$ 数组，此时很清晰的知道 $siz[3] = 7$ ，因为是以 $1$ 为根深搜的。很明显，一开始这整棵树的重心是 6 号节点，那么接下来，我们可以发现：\n当从点 $6$ 开始 dfs 时，有 $6$-\u0026gt;$3$ 这条边，那么按理来说，$size = siz[3]$，此时 $size$ 表示的是以 $3$ 为根的子树的大小，可看图上明明是 $5$ 啊（在点 $3$ 的左边，不包含点 $6$ 那边）。可是此时的 $siz[3]$ 为 $7$，而并非是 $5$ 。这是由于选定的深搜节点不同，统计的不同而导致的。$siz[3]$ 的正确值理应来自于从 点 $6$ 开始深搜的值。 故我们可以得出结论，用 getroot(1,0) 找到整棵树的重心之后，再来一次 getroot(root, 0)，来确定以重心为根结点时的 $siz$ 数组。这下就可以直接 size = siz[v] 了。\n11 1 6 7 1 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 2 不要用 memset 粗暴还原，会浪费很多时间。\n例二 Luogu P4178 Tree：给定一棵有 $n$ 个点的带权树，给出 $k$，询问树上距离小于等于 $k$ 的点对数量。\n$n\\le 40000,k\\le 20000,w_i\\le 1000$\n这题方法比较多。下面的代码用 容斥 进行去重和 双指针 （除此之外还可以用二分）统计答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int calc(int u, int w) { dis.clear(); getDis(u, -1, w); sort(dis.begin(), dis.end()); int sum = 0; int L = 0, R = dis.size() - 1; // 双指针 while (L \u0026lt; R) { if (dis[L] + dis[R] \u0026lt;= k) sum += R - L, L++; else R--; } return sum; } void solve(int u, int size) { centroid = 0; getCentroid(u, -1, size); getCentroid(centroid, -1, size); vis[centroid] = true; ans += calc(centroid, 0); for (auto i : g[centroid]) { if (vis[i.first]) continue; ans -= calc(i.first, i.second); // 容斥。去除错误的答案。 } for (auto i : g[centroid]) { if (vis[i.first]) continue; solve(i.first, siz[i.first]); } } 例三 暂且咕咕咕。🕊\n习题 Luogu P4149 [IOI2011]Race Luogu P3714 [BJOI2017]树的难题 Luogu P2634 [国家集训队]聪聪可可 参考资料 《挑战程序设计竞赛》 OI Wiki 🙇‍\n","date":"August 2022","permalink":"https://blog.chungzh.cn/articles/centroid-decomposition/","tags":["OI","算法","数据结构","树的重心","点分治"],"title":"点分治笔记"},{"categories":"瞎搞开发","contents":"上一次折腾博客已经是不知道什么时候的事情了。。\nHugo 这个框架很不错，不想更换，那就尝试做一个主题吧。\nHugo-klay 这个名字取自我最喜欢的 NBA 球员 Klay Thompson，不久前他随金州勇士队夺得了 2021-2022 赛季的 NBA 总冠军。\n实话说，我的前端是零基础水平，JS 完全不会写。感谢非常容易上手的 tailwindcss 框架，同时还借（抄）鉴（袭）了很多 hugo-tania、hugo-theme-stack 和 hugo-tailwindcss-starter-theme 的代码。\n就像前面说的那样，这个主题的代码质量比较差，而且主要也是自己使用，所以暂时不会单独为这个主题开一个 repo。如果你想参考，也可以到 ChungZH.github.io 这里寻找源码。有时间 的话，我会整理一下代码，再考虑单独分成一个项目。\n自我感觉还是挺漂亮的，哈哈哈。\n","date":"July 2022","permalink":"https://blog.chungzh.cn/articles/hugo-klay/","tags":["Hugo","主题","blog","tailwind"],"title":"第一次做主题：hugo-klay"},{"categories":"学习笔记","contents":" 前言 写一道 CF 题的时候，算法明明是正确的，却一直都 TLE。最后把一个 long long 类型的数组改成了 int，竟然就 AC 了。。\n这不禁引发了我的思考，int 与 long long 的运算速度不一样吗？\n不严谨测试 由于本菜鸡并没有什么计算机基础原理的知识，只好做了一个测试。当然，这个测试其实很不严谨，没有很大的参考价值。我也就图一乐，哈哈哈哈哈\n测试环境 电脑：Lenovo Yoga 14sACH 2021 系统：Windows 11 25163.1010 CPU：AMD Ryzen 7 5800H with Radeon Graphics (16) @ 3.200GHz RAM：16.0 GB 编译器：GCC 11.2.0 代码 仅仅是为了图一乐， 我第一次使用了 Google Benchmark 这一工具。其实挺好上手的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;benchmark/benchmark.h\u0026gt; using namespace benchmark; static void int_add(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) + (++b)); } static void ll_add(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) + (++b)); } static void int_div(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) / (++b)); } static void ll_div(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) / (++b)); } static void int_mod(State \u0026amp;state) { int a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) % (++b)); } static void ll_mod(State \u0026amp;state) { long long a = std::rand(), b = std::rand(), c = 0; for (auto _ : state) DoNotOptimize(c = (++a) % (++b)); } BENCHMARK(int_add)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_add)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(int_div)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_div)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(int_mod)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK(ll_mod)-\u0026gt;Threads(8)-\u0026gt;Iterations(1e9); BENCHMARK_MAIN(); 结果 1 2 3 4 5 6 7 8 9 10 --------------------------------------------------------------------- Benchmark Time CPU --------------------------------------------------------------------- int_add/iterations:1000000000/threads:8 0.209 ns 1.57 ns ll_add/iterations:1000000000/threads:8 0.225 ns 1.71 ns int_div/iterations:1000000000/threads:8 0.302 ns 2.29 ns ll_div/iterations:1000000000/threads:8 0.306 ns 2.38 ns int_mod/iterations:1000000000/threads:8 0.345 ns 2.18 ns ll_mod/iterations:1000000000/threads:8 0.350 ns 2.34 ns 经过多次测试，long long 类型的各种运算都比 int 慢一点。\nStackOverflow 问答 比较专业的一个解答。详见 performance - C++ int vs long long in 64 bit machine - Stack Overflow。\n这里引用相关问答：\n1) If it is best practice to use long long in x64 for achieving maximum performance even for for 1-4 byte data?\nNo- and it will probably in fact make your performance worse. For example, if you use 64-bit integers where you could have gotten away with 32-bit integers then you have just doubled the amount of data that must be sent between the processor and memory and the memory is orders of magnitude slower. All of your caches and memory buses will crap out twice as fast.\n结论 可以不用 long long 就尽量不用。最好不要使用 #define int long long 这种粗暴手段。\n致谢：\nC++ Benchmarking Tips for Beginners - Unum Blog 碎碎念：真的有大半年没写过博客了，上次更新还是寒假呢哈哈哈。一整个学期都好忙啊，接下来就是初三了呢。\n🙇\n","date":"July 2022","permalink":"https://blog.chungzh.cn/articles/int-vs-longlong/","tags":["C++","OI"],"title":"关于 int 与 long long 的运算速度"},{"categories":"学习笔记","contents":" Treap = Tree + Heap\n二叉搜索树（BST） 在学习 Treap 之前，需要先了解一下二叉搜索树（BST, Binary Search Tree）：\n设 $x$ 是二叉搜索树中的一个结点。如果 $y$ 是 $x$ 左子树中的一个结点，那么 $y.key \\lt x.key$。如果 $y$ 是 $x$ 右子树中的一个结点，那么 $y.key \\gt x.key$。\nBST 上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 $n$ 个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\\log n)$，最坏为 $O(n)$。随机构造这样一棵二叉搜索树的期望高度为 $O(\\log n)$。然而，当这棵树退化成链时，则同样的操作就要花费 $O(n)$ 的最坏运行时间。\n由于普通 BST 容易退化，对于它的实现就不再赘述。在实践中需要使用如 Treap 这样的平衡二叉搜索树。\nTreap 顾名思义，Treap 是树和堆的结合。它的数据结构既是一个二叉搜索树，又是一个二叉堆。\n在 Treap 的每个结点中，除了 $key$ 值，还要保存一个 $fix$（更常见的是 $priority$）值。这个值是随机值，以它为依据来同时建立最大堆（或最小堆）。因为 $fix$ 值是随机的，所以可以让这棵树更加平衡，高度更接近 $O(\\log n)$。它的各种操作期望时间复杂度都是 $O(\\log n)$。\n旋转式 Treap 旋转式 Treap 的常数较小。\n旋转 左旋/右旋操作不会破坏 BST 的性质，并可以通过它来维护堆，使树平衡。\n如图，以右旋为例。假设现在左边树 $b$ 的 $fix$ 值大于 $a$ 的 $fix$ 值，然而 $b$ 是 $a$ 的儿子，那么就不符合最大堆的性质，需要进行右旋，变成了右边的树。\n但是为什么在旋转的过程中没有破坏 BST 的性质呢？设 $c \\in C, d \\in D, e \\in E$。由左树知 $c \\lt b \\lt d \\lt a \\lt e$。再由旋转之后树的结构可以得出 $c \\lt b \\lt d \\lt a \\lt e$，这两个式子是一样的。所以，这棵树依然是 BST。\n在插入和删除操作中都要按需进行旋转操作。\n插入 根据 BST 的性质，找到相应的位置创建新叶子结点就可以了。如果不符合最大堆性质，进行旋转操作。\n删除 删除一个元素时，可以对被删除的结点分类讨论：\n没有子结点：直接就成空的了 只有一个子结点：把被删除结点设成它仅有的儿子即可 有两个子结点：选出两个儿子中 $fix$ 值较大的一个，通过旋转操作把它设成新的根，这样要删除的结点就只有一个儿子了，按照情况 2 处理。这种方法保证满足了 BST 和最大堆的性质。 在程序实现时，实际上情况 1 和 2 的代码是一样的，所以只用分两类。\n以 P3369 【模板】普通平衡树 - 洛谷 为例，代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int INF = 1000000009; struct NODE { int val, fix, size; // size 指树的总结点数 NODE *left, *right; NODE(const int val) : val(val) { fix = rand(); left = right = NULL; size = 1; } }; void maintain(NODE *\u0026amp;p) { p-\u0026gt;size = 1; if (p-\u0026gt;left != NULL) p-\u0026gt;size += p-\u0026gt;left-\u0026gt;size; if (p-\u0026gt;right != NULL) p-\u0026gt;size += p-\u0026gt;right-\u0026gt;size; } void rightRotate(NODE *\u0026amp;p) { NODE *tmp = p-\u0026gt;left; p-\u0026gt;left = tmp-\u0026gt;right; tmp-\u0026gt;right = p; p = tmp; maintain(tmp-\u0026gt;right); maintain(tmp); } void leftRotate(NODE *\u0026amp;p) { NODE *tmp = p-\u0026gt;right; p-\u0026gt;right = tmp-\u0026gt;left; tmp-\u0026gt;left = p; p = tmp; maintain(tmp-\u0026gt;left); maintain(tmp); } void insert(NODE *\u0026amp;p, const int value) { if (p == NULL) { p = new NODE(value); } else if (value \u0026lt;= p-\u0026gt;val) { insert(p-\u0026gt;left, value); if (p-\u0026gt;left-\u0026gt;fix \u0026lt; p-\u0026gt;fix) rightRotate(p); } else { insert(p-\u0026gt;right, value); if (p-\u0026gt;right-\u0026gt;fix \u0026lt; p-\u0026gt;fix) leftRotate(p); } maintain(p); } int count(const NODE *p, const int value) { if (!p) return 0; if (p-\u0026gt;val == value) return 1; if (value \u0026lt;= p-\u0026gt;val) return count(p-\u0026gt;left, value); return count(p-\u0026gt;right, value); } void remove(NODE *\u0026amp;p, const int value) { if (!p) return; if (p-\u0026gt;val == value) { if (p-\u0026gt;left == NULL || p-\u0026gt;right == NULL) { NODE *tmp = p; if (p-\u0026gt;right) p = p-\u0026gt;right; else p = p-\u0026gt;left; delete tmp; } else if (p-\u0026gt;left-\u0026gt;fix \u0026lt; p-\u0026gt;right-\u0026gt;fix) { rightRotate(p); remove(p-\u0026gt;right, value); maintain(p); } else { leftRotate(p); remove(p-\u0026gt;left, value); maintain(p); } } else if (value \u0026lt; p-\u0026gt;val) { remove(p-\u0026gt;left, value); maintain(p); } else { remove(p-\u0026gt;right, value); maintain(p); } } int getrank(const NODE *p, int value) { if (!p) return INF; int leftsize = 0; if (p-\u0026gt;left != NULL) leftsize = p-\u0026gt;left-\u0026gt;size; if (p-\u0026gt;val == value) return min(leftsize + 1, getrank(p-\u0026gt;left, value)); else if (value \u0026lt; p-\u0026gt;val) return getrank(p-\u0026gt;left, value); else if (value \u0026gt; p-\u0026gt;val) return leftsize + 1 + getrank(p-\u0026gt;right, value); } int find(const NODE *p, int rank) { if (!p) return 0; int leftsize = 0; if (p-\u0026gt;left != NULL) leftsize = p-\u0026gt;left-\u0026gt;size; if (leftsize \u0026gt;= rank) return find(p-\u0026gt;left, rank); else if (leftsize + 1 == rank) return p-\u0026gt;val; else return find(p-\u0026gt;right, rank - leftsize - 1); } int getpre(const NODE *p, int value) { // 前驱 if (!p) return -INF; if (p-\u0026gt;val \u0026gt;= value) return getpre(p-\u0026gt;left, value); else return max(p-\u0026gt;val, getpre(p-\u0026gt;right, value)); } int getnext(const NODE *p, int value) { // 后继 if (!p) return INF; if (p-\u0026gt;val \u0026lt;= value) return getnext(p-\u0026gt;right, value); else return min(p-\u0026gt;val, getnext(p-\u0026gt;left, value)); } int n; NODE *root; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n-- \u0026gt; 0) { int opt, x; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;opt, \u0026amp;x); if (opt == 1) { insert(root, x); } else if (opt == 2) { remove(root, x); } else if (opt == 3) { printf(\u0026#34;%d\\n\u0026#34;, getrank(root, x)); } else if (opt == 4) { printf(\u0026#34;%d\\n\u0026#34;, find(root, x)); } else if (opt == 5) { printf(\u0026#34;%d\\n\u0026#34;, getpre(root, x)); } else if (opt == 6) { printf(\u0026#34;%d\\n\u0026#34;, getnext(root, x)); } } return 0; } 无旋 Treap 无旋 Treap 的核心操作是分裂、合并。\n分裂（Split） 分裂操作会将原 Treap 一分为二，第一个 Treap 中的结点关键值都小于等于 $key$，第二个中都大于 $key$。使用递归实现。\n若当前关键值大于 $key$，那么当前结点连同右子树都属于第二个 Treap，继续往左子树递归。\n若当前关键值小于等于 $key$，那当前结点连同左子树都属于第一个 Treap。继续往右子树递归。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pair\u0026lt;NODE *, NODE *\u0026gt; split(NODE *u, const int value) { if (u == nullptr) return make_pair(nullptr, nullptr); if (u-\u0026gt;value \u0026gt; value) { auto tmp = split(u-\u0026gt;ch[0], value); u-\u0026gt;ch[0] = tmp.second; maintain(u); return make_pair(tmp.first, u); } else { auto tmp = split(u-\u0026gt;ch[1], value); u-\u0026gt;ch[1] = tmp.first; maintain(u); return make_pair(u, tmp.second); } } 合并（Merge） 合并函数接受两棵树，其中第一棵的值都小于第二棵。每一次根据两棵树的根的 $fix$ 值来确定新树的根，然后递归合并子树。\n当两棵树任何一个为空时，返回另一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 NODE *merge(NODE *l, NODE *r) { if (l == nullptr) return r; if (r == nullptr) return l; if (l-\u0026gt;fix \u0026lt; r-\u0026gt;fix) { l-\u0026gt;ch[1] = merge(l-\u0026gt;ch[1], r); maintain(l); return l; } // else r-\u0026gt;ch[0] = merge(l, r-\u0026gt;ch[0]); maintain(r); return r; } 插入 将树分裂成两个部分：$A=\\lbrace x \\mid x \\le key \\rbrace$、$B= \\lbrace x \\mid x \\gt key \\rbrace$，先将要插入的值合并入 $A$，最后合并 $A$ 和 $B$。\n1 2 3 4 5 void insert(int value) { auto tmp = split(root, value); tmp.first = merge(tmp.first, new NODE(value)); root = merge(tmp.first, tmp.second); } 删除 将树分裂成三个部分：$A= \\lbrace x \\mid x \\lt key \\rbrace$、$B= \\lbrace x \\mid x = key \\rbrace$、$C= \\lbrace x \\mid x \\gt key \\rbrace$，然后合并 $A$ 和 $C$。\n1 2 3 4 5 6 void erase(int value) { auto tmp = split(root, value - 1); auto tmp2 = split(tmp.second, value); delete tmp2.first; root = merge(tmp.first, tmp2.second); } 致谢：\nYWQ (Monad) OI Wiki CC BY-SA 4.0 《算法导论》 Algorithms for Competitive Programming CC BY-SA 4.0 Treap - Wikipedia CC BY-SA 3.0 ","date":"February 2022","permalink":"https://blog.chungzh.cn/articles/treap/","tags":["OI","算法","数据结构","Treap"],"title":"Treap 笔记"},{"categories":"生活","contents":"这一年还是收获满满的。\nOI 上半年去了 GDOI 观摩神仙打架，长了见识。\nCSP-J 2021 1=，挺满意的。\n年末镇赛第一，虽然说没什么用但是就是挺开心的 😁\n总的来说，进步挺大的。\n学习 是真正的初中生了。\n几次大考，有成功，也有失利。可以说对于学习的心态变成熟了。\n值得一提的是，十月份的时候换了一个校长，带来了很多新气象，幸福感不断提升。期待他在以后的表现。\n生活 爱上了 🏓 乒乓球，买了一个五百多的拍子，奢侈了一把，真爽（\n对运动的热情高涨了很多。\n总之，希望在新的一年，一切都会更好！\n","date":"December 2021","permalink":"https://blog.chungzh.cn/articles/goodbye2021/","tags":["总结"],"title":"告别 2021"},{"categories":"游记","contents":" CSP-J/S 认证注意事项：\n\u0026hellip;\u0026hellip;\n11. 祝各位选手好运。\nCSP-J1 初赛前有点小紧张。\n赛前勉强做了几套试卷，然后就上考场了。\n刚考完对答案的时候发现 J 组才 72，看洛谷上大家都说今年 J 组简单了 blabla，分数线肯定会升，然而我却觉得好难，那一个星期都害怕极了。。。结果分数出来了才发现洛谷那群人真是扯啊哈哈哈\nS 组才 48 分，没有成功压线。（其实就算去了复赛也拿不了分。。\nCSP-J2 比赛前一晚上八点在学校出发。逃掉了晚自习（尽管是星期五\n去到酒店大概也九点半了，洗完澡，看了会儿凤凰台，然后就睡了。\n第二天早上六点半起床，吃完自助餐（和上一年的变化不大，挺好吃的），七点二十出发。\n然后进考场。\n电脑好像是 Ryzen 3600，8GB 内存。\n八点半开考。\n密码很乱，6ewid\\n16384#，监考员一开始还直接忽略最后面那个井号了。。。\n打开题目，发现第一第二题题面好长，有点慌了起来\u0026hellip;\nT2 尤为毒瘤，到了 9:22 才搞完了。。。感觉挺很危险的，好怕翻车。\n10:08，肝完 T3，77 行代码，写完人都瘫了。。感谢第三个样例，一个一个找情况。。。\n（不知道怎么比对两个文件的内容，于是直接打开 Sublime Text 开始用查找来找不同。。。\n赶紧吃了根士力架，然后去上了个厕所。\n10:55，T4 过样例了，打得比 T3 轻松多了，当然也不可能拿满分。。。其实也不知道该怎么做，直接乱搞，做法非常诡异。。看看效果怎样吧，能骗到 50 分就是胜利。\n还有一点，今年 NOI Linux 2 还行。（毕竟上一年给了虚拟机但是系统有密码，根本打不开，笑死）在里面编译了几次代码，虽然也没什么用。运行起来还蛮快的。\n总的来说，这次考得还行。题目有点诡异，没有 dp，没有搜索，个人感觉侧重考基本功。\n等成绩吧。\nUPD 1 (2021/10/23 22:50)：\n广东源代码出了。\ncandy: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long n, L, R; int main() { freopen(\u0026#34;candy.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;candy.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; long long LRCHA = (R-L+1); long long LCN = L/n, RCN = R/n; if (RCN \u0026gt; LCN) { cout \u0026lt;\u0026lt; n-1 \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; R-LCN*n \u0026lt;\u0026lt; endl; return 0; } sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, Q; long long a[8005]; int idxa[8005]; bool cmp(int i1, int i2) { if (a[i1] != a[i2]) return a[i1] \u0026lt; a[i2]; return i1 \u0026lt; i2; } int main() { freopen(\u0026#34;sort.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;sort.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;Q); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); while (Q--) { int type; scanf(\u0026#34;%d\u0026#34;, \u0026amp;type); if (type == 1) { // �޸� int x; long long v; scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;x, \u0026amp;v); a[x] = v; for (int i = 1; i \u0026lt;= n; i++) idxa[i] = i; sort(idxa+1, idxa+1+n, cmp); } else if (type == 2) { // ��ѯ int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int i = 1; i \u0026lt;= n; i++) { if (idxa[i] == x) { printf(\u0026#34;%d\\n\u0026#34;, i); break; } } } } return 0; } network: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; bool checkPrevZero(const string number) { if (number.length() \u0026gt; 1 \u0026amp;\u0026amp; number[0] == \u0026#39;0\u0026#39;) return true; return false; } int strToInt(const string number) { int t = 0; for (int i = 0; i \u0026lt; number.length(); i++) { t *= 10; t += number[i]-\u0026#39;0\u0026#39;; } return t; } bool check(const string addr) { int cntDot = 0, cntMao = 0; int dotIdx[3], maoIdx;\tif (!(addr[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[0] \u0026lt;= \u0026#39;9\u0026#39;) || !(addr[addr.length()-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[addr.length()-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; for (int i = 0; i \u0026lt; addr.length(); i++) { if (addr[i] == \u0026#39;.\u0026#39;) { if (cntDot \u0026gt; 2) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntDot++; dotIdx[cntDot-1] = i; } else if (addr[i] == \u0026#39;:\u0026#39;) { if (cntMao \u0026gt; 1) return false; if (!(addr[i-1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i-1] \u0026lt;= \u0026#39;9\u0026#39;)) return false; cntMao++; maoIdx = i; } else if (!(addr[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; addr[i] \u0026lt;= \u0026#39;9\u0026#39;)) { return false; } } if (!(cntDot == 3 \u0026amp;\u0026amp; cntMao == 1)) return false; if (maoIdx \u0026lt; dotIdx[2]) return false; string n1 = addr.substr(0, dotIdx[0]), n2 = addr.substr(dotIdx[0]+1, dotIdx[1]-dotIdx[0]-1), n3 = addr.substr(dotIdx[1]+1, dotIdx[2]-dotIdx[1]-1), n4 = addr.substr(dotIdx[2]+1, maoIdx-dotIdx[2]-1), n5 = addr.substr(maoIdx+1, addr.length()-maoIdx-1); //cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n4 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n5 \u0026lt;\u0026lt; endl; if (checkPrevZero(n1) || checkPrevZero(n2) || checkPrevZero(n3) || checkPrevZero(n4) || checkPrevZero(n5)) return false; if (n1.length() \u0026gt; 3 || n2.length() \u0026gt; 3 || n3.length() \u0026gt; 3 || n4.length() \u0026gt; 3 || n5.length() \u0026gt; 5) return false; int a = strToInt(n1), b = strToInt(n2), c = strToInt(n3), d = strToInt(n4), e = strToInt(n5); if (a \u0026gt; 255 || b \u0026gt; 255 || c \u0026gt; 255 || d \u0026gt; 255 || e \u0026gt; 65535) return false; return true; } int serversNum = 0; map\u0026lt;string, int\u0026gt; servers; int main() { freopen(\u0026#34;network.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;network.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n; string op, ad; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; ad; if (!check(ad)) { cout \u0026lt;\u0026lt; \u0026#34;ERR\\n\u0026#34;; continue; } if (op == \u0026#34;Server\u0026#34;) { if (servers[ad] != 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } servers[ad] = i+1; cout \u0026lt;\u0026lt; \u0026#34;OK\\n\u0026#34;; } else if (op == \u0026#34;Client\u0026#34;) { if (servers[ad] == 0) { cout \u0026lt;\u0026lt; \u0026#34;FAIL\\n\u0026#34;; continue; } cout \u0026lt;\u0026lt; servers[ad] \u0026lt;\u0026lt; endl; } } return 0; } fruit: （代码非常奇妙，思路十分无理，建议不要看）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct node { int idx; int val; int ai; int len; }; int n; int a[200005]; vector\u0026lt;node\u0026gt; sons[405005]; int nodeNums = 1; void buildtree(int root, int left, int right, bool rrr) { if (rrr) { int prev = 1; for (int i = 2; i \u0026lt;= n; i++) { if (a[i] != a[prev]) { sons[1].push_back({nodeNums+1, a[prev], prev, i-prev}); buildtree(nodeNums+1, prev, i-1, 0); nodeNums++; prev = i; } } sons[1].push_back({nodeNums+1, a[prev], prev, n-prev+1}); buildtree(nodeNums+1, prev, n, 0); nodeNums++; } else { for (int i = left; i \u0026lt;= right; i++) { sons[root].push_back({++nodeNums, a[left], i, 1}); } } } void work() { for (int i = 0; i \u0026lt; sons[1].size(); i++) { printf(\u0026#34;%d \u0026#34;, sons[sons[1][i].idx][0].ai); sons[sons[1][i].idx].erase(sons[sons[1][i].idx].begin()); if (sons[sons[1][i].idx].size() == 0) { sons[1].erase(sons[1].begin()+i); i--; } } // merge for (int i = 1; i \u0026lt; sons[1].size(); i++) { if (sons[1][i].val != sons[1][i-1].val) continue; int id = sons[1][i].idx; for (int j = 0; j \u0026lt; sons[id].size(); j++) { sons[sons[1][i-1].idx].push_back(sons[id][j]); } sons[1].erase(sons[1].begin()+i); i--; } printf(\u0026#34;\\n\u0026#34;); } int main() { freopen(\u0026#34;fruit.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;fruit.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } buildtree(1, 1, n, 1); while (sons[1].size()) { work(); } return 0; } 洛谷自测：342 = 100 + 72 + 100 + 70\n计蒜客自测：342 = 100 + 52 + 100 + 90\n目前看上去 1= 稳了。\nUPD 2 (2021/10/30 22:38)：\nCCF 官方：100 + 52 + 100 + 70 = 322\n","date":"October 2021","permalink":"https://blog.chungzh.cn/articles/csp2021/","tags":["游记","OI","CSP"],"title":"CSP-J 2021 游记"},{"categories":"学习笔记","contents":"线段树是一种高端的数据结构，可以用来在区间上进行信息统计。它能够在 $O(logN)$ 的时间复杂度内实现单点/区间修改、区间找最大值/最小值/总和/\u0026hellip;，适用于大规模的区间统计。\n如下图就是一棵线段树。在结点中，你可以存对应区间的最大值，最小值，总和等等。\n对于每一个结点 $i$，它的两个子结点分别是 $2i$ 和 $2i+1$。因此，在开树的数组时，最好要开到 $4N$ 的大小。\n关于 $4N$，详见 OI-Wiki。\n建树 下面是一个求区间和的线段树的建树代码。\n通过 DFS 建树，到叶结点，然后一路回溯求出和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void build_tree(int cur, int left, int right) { // cur 为当前树的根，[left, right] 是当前树对应的区间 if (left == right) { // 到叶子节点了，区间长度为 1，总和就是它本身 tree[cur] = a[left]; return ; } int leftSon = cur*2, rightSon = leftSon+1; int mid = (left+right)/2; build_tree(leftSon, left, mid); build_tree(rightSon, mid+1, right); tree[cur] = tree[leftSon]+tree[rightSon]; // 求和 } 这里求 leftSon，rightSon，mid 的模式在线段树的所有操作中都会用到。\n区间查询 对于一个不恰好的区间，我们可以不断地把它拆分成两个恰好的区间再进行合并。\n如图所示，拆分过程如下：\n[3, 7] [3, 4], [5, 7] [3, 4], [5, 6], [7, 7] 在实际 DFS 过程中，我们可以分为三种情况：\n当前结点对应区间和要查询的区间完全无关，直接退出 当前结点对应区间完全处于要查询的区间范围，返回当前结点的值 两个区间部分相交，继续拆分为 1 或 2 情况 1 2 3 4 5 6 7 8 9 long long query(int cur, int l, int r, int x, int y) { // cur 为当前树的根，[l, r] 是当前树对应的区间，[x, y] 是要查询的区间 if (y \u0026lt; l || r \u0026lt; x) return 0; // 1. 相离 if (x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) return tree[cur]; // 2. 完全包含 // 3. 相交 int leftSon = cur*2, rightSon = leftSon+1; int mid = (l+r)/2; return query(leftSon, l, mid, x, y) + query(rightSon, mid+1, r, x, y); // 求和 } 区间修改 单点修改并没有什么意思，就不讲了。\n区间修改当然不是重复做单点修改，否则使用线段树就很没有必要了。为了避免走到底下去，我们要使用一个懒惰标记（lazy tag）。当一个大区间内所有的小单位都要进行同样的修改操作时，只需要在大区间做一次标记就可以了。到了必须要走下去（即查询更小的区间或修改更小的区间）的时候，再把懒惰标记下放。\n下面以一个区间增加一个值并进行区间查询为例。\n首先定义一个结构体，其中 add 就是记录这个区间需要增加的值。\n1 2 3 4 struct node { long long sum, add; } tree[4 * MAXN]; 下放操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void pushdown(int cur, int left, int mid, int right) { // 将当前结点的 add 值下放给子结点 const int leftSon = cur * 2, rightSon = leftSon + 1; // 更新总和（区间元素个数*每个元素要增加的值） tree[leftSon].sum += (mid - left + 1) * tree[cur].add; tree[rightSon].sum += (right - mid) * tree[cur].add; // 更新 add 值 tree[leftSon].add += tree[cur].add; tree[rightSon].add += tree[cur].add; // 当前结点的懒惰标记已经下放，需要清零 tree[cur].add = 0; } 区间增加一个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void update(int cur, int left, int right, int x, int y, ll c) { if (left \u0026gt; y || right \u0026lt; x) // 相离 return; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // 完全包含 { // 给当前区间整体增加 c tree[cur].sum += (right - left + 1) * c; // 打标记 tree[cur].add += c; // 这时不需要子结点的值，所以不必下放 return; } // 相交 // 分成两个子区间，必须要往下走了 int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // 先下放标记 update(leftSon, left, mid, x, y, c); update(rightSon, mid + 1, right, x, y, c); tree[cur].sum = tree[2 * cur].sum + tree[2 * cur + 1].sum; // 最后汇总总和 } 区间查询：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ll query(int cur, int left, int right, int x, int y) { if (left \u0026gt; y || right \u0026lt; x) // 相离 return 0; if (left \u0026gt;= x \u0026amp;\u0026amp; right \u0026lt;= y) // 完全包含 return tree[cur].sum; // 相交 // 拆成两个字区间再求和 int mid = (left + right) / 2; int leftSon = cur * 2, rightSon = leftSon + 1; pushdown(cur, left, mid, right); // 必须往下走，下放标记 return query(leftSon, left, mid, x, y) + query(rightSon, mid + 1, right, x, y); } 通过上面的代码，我们可以看到：懒惰标记就是为了不往下走，尽量在更大的区间做一次操作。必要时才往下下放标记。它不会主动做事，而是到你需要的时候才花时间去做。通过这样节省了很多时间。\n小结 总的来说，线段树不是一个很难的数据结构，但是很实用。\n感谢 lgj 老师！\n","date":"August 2021","permalink":"https://blog.chungzh.cn/articles/segment-tree/","tags":["OI","算法","数据结构","线段树"],"title":"线段树笔记"},{"categories":"瞎搞开发","contents":"暑假来了，顺便把博客更新一下。\n从以前的 Vuepress 变成了 Hugo，速度真的快了很多，不愧是 \u0026ldquo;The world’s fastest\u0026rdquo;。用的主题是 Tania，很简洁、漂亮。Hugo 非常易用，不到半天就完整迁移过来了。我可以很肯定地说这一次博客迁移是有史以来最快的一次。\nCI 用的是 GitHub Actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: github pages on: push: branches: - hugo # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: master # default: gh-pages 总之就是非常丝滑，Hugo NB!\n","date":"July 2021","permalink":"https://blog.chungzh.cn/articles/hello-hugo/","tags":["Blog","Hugo"],"title":"Hello Hugo!"},{"categories":"游记","contents":" 他山之石，可以攻玉。\nCSP-J1 入学你校几乎两个月都在搞初赛。\n结果初一还是只有两个人过了\n最后是 73.5 分，水过去了。\nCSP-J2 Day 0 要去大学城的广大附中，就去住酒店了。\n在 tjl 大佬房间里 玩，其实是在看凤凰台。\n依稀记得那晚上拜登和特朗普的比分是 264 : 214，林郑去北京见韩正了。\nCCTV-7 上面中科院在帮农民种橘子？\n十点多就回去昏昏沉沉地睡了，还挺香（\nDay 1 早上六点半就醒了。\n在酒店吃了顿自助早餐，真香。\n到处都是石实的大佬 %%% 。\n然后搭着同校热心家长的车前往广大附中。\n门口还挺热闹的，好像发生了许多事情：\n黄老师身份证不见了，其实藏在袋子里 某大佬没带准考证 还有没带粤康码的 于是感到很庆幸，没入考场的时候也是一场考验。。所以说带齐资料很重要。\n很快就进考场了。\n电脑有 8G 内存，装的是 Windows 10 神州网信政府版，感觉只是开始菜单看上去稍有不同。\n下发题目之后几分钟我还在打 A+B，打完之后才一愣一愣地抄密码解压题目。\n翻了一下，发现第一题好难，于是从第二题开始做。\nT2 刚开始竟然用了 sort，到了最后试大样例的时候才看到一卡一卡的，于是又改成了插入排序，以为没问题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool cmp(int a, int b) { return a \u0026gt; b; } int a[100005]; int main() { int n, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); for (int i = 0; i \u0026lt; n; i++) { int inp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;inp); int j = 0; for (; j \u0026lt; i; j++) { if (a[j] \u0026lt; inp) break; } for (int k = i; k \u0026gt;= j; k--) { a[k+1] = a[k]; } a[j] = inp; int planNum = max(1, (int)((i+1)*0.01*w)); printf(\u0026#34;%d \u0026#34;, a[planNum-1]); } return 0; } 然后 T3 看了好久才弄懂，就暴力 stack 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int n; int a[100003]; int main() { string expr; getline(cin, expr); const int exprlen = expr.length(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int q; scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; q; i++) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); a[t] = !a[t]; string cur; for (int j = 0; j \u0026lt; exprlen+1; j++) { if (j == exprlen || expr[j] == \u0026#39; \u0026#39;) { if (cur == \u0026#34;!\u0026#34;) { int t = s.top(); s.pop(); s.push(!t); } else if (cur == \u0026#34;\u0026amp;\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t \u0026amp;\u0026amp; t2); } else if (cur == \u0026#34;|\u0026#34;) { int t = s.top(); s.pop(); int t2 = s.top(); s.pop(); s.push(t || t2); } else if (cur[0] == \u0026#39;x\u0026#39;) { int xb = 0; for (int k = 1; k \u0026lt; cur.length(); k++) { xb *= 10; xb += cur[k]-\u0026#39;0\u0026#39;; } s.push(a[xb]); } cur.clear(); } else cur += expr[j]; } printf(\u0026#34;%d\\n\u0026#34;, s.top()); if (!s.empty()) s.pop(); a[t] = !a[t]; } return 0; } 接下来才开始构思第一题，一直摸不着头绪，就随随便便写了一个爆搜，枚举 2 的幂相加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; const int a[23] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608}; int ansn = 0, ans[24]; int dfs(int step, int sum) { if (sum \u0026gt; n) return 0; if (step \u0026gt; 23) return 0; if (sum == n) { return 1; } for (int i = 1; i \u0026lt;= 22; i++) { int t1 = dfs(step+i, sum + a[step]); if (t1) { ans[ansn++] = a[step]; return 1; } } } int main() { cin \u0026gt;\u0026gt; n; if (n % 2 != 0) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } for (int i = 0; i \u0026lt; 23; i++) { if (n == a[i]) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; endl; return 0; } } dfs(0, 0);\tfor (int i = 0; i \u0026lt; ansn; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; } 第四题直接无脑爆搜，能拿到暴力分就 ok。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long ans = -99999999999; int a[1005][1005], n, m; bool vis[1005][1005]; const int dx[3] = { -1, 1, 0 }; const int dy[3] = { 0, 0, 1 }; void dfs(int x, int y, long long sum) { if (x == n \u0026amp;\u0026amp; y == m) { // 终点 ans = max(ans, sum+a[x][y]); return ; } for (int i = 0; i \u0026lt; 3; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 1 || ny \u0026lt; 1 || nx \u0026gt; n || ny \u0026gt; m) continue; if (vis[nx][ny]) continue ; vis[nx][ny] = 1; dfs(nx, ny, sum + a[x][y]); vis[nx][ny] = 0; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); vis[i][j] = false; } } dfs(1, 1, 0); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 出了考场之后和 tjl 对答案，才知道第一题考的是二进制，第二题要用桶排序。。。\n然后那时竟然还挺乐观的，觉得我的也没问题。。。\n甚至还开始讨论有没有 1= 。。。。。。。。。\n直到洛谷上了民间数据自测。\n100 + 80 + 30 + 15 = 225\n还是看看能不能有二等吧。。\n总之达到了考前的期望，考后还是太自信了一点点。也没什么遗憾，正常发挥出了自己的水平。\n那么就：\nCSP-J/S 2021 RP++\nUPD: 215 分，2=\n","date":"November 2020","permalink":"https://blog.chungzh.cn/articles/csp-j-2020/","tags":["游记","OI","CSP"],"title":"CSP-J 2020 游记"},{"categories":"瞎搞开发","contents":" 前言 最近开始学习 Qt，然后就挖坑了一个小玩具 Notepanda，顺便看看能不能替代诸如 notepad、gedit 之类的软件。顺便锻炼一下自己。\nGitHub repo\nFeature 基本的文本编辑操作（没想到吧这也是 feature 了哈哈哈哈哈哈） 行号显示 语法高亮 从命令行启动。（如 notepanda 或者 notepanda CMakeLists.txt） 除此之外还实现了自定义字体、字号、Qt 主题和 Status Bar 等一些小功能。\n以后的目标是实现多标签页，并对 Markdown 做一点优化（比如预览），如果有可能还会加进去一个 terminal。计划在 GitHub Projects。\n目前还是很弱的一个东西，不过等查找、替换等 feature 实现之后，基本上可以替代 Windows 的 notepad 了。\nScreenshots 实现 这部分大概讲讲思路吧。\n布局 编辑控件 使用了 Qt 提供的 QPlainTextEdit 类，适合纯文本编辑。刚开始还用的是 QTextEdit，想想自己真是傻了，又不是要编辑富文本哈哈哈。\n不过 QPlainTextEdit 似乎有点点慢，我也没能力造轮子，于是就将就着用吧。\n语法高亮 刚开始想实现的时候看见了 Qt 官方的 Syntax Highlighter Example，很棒对吧。但是我可不想花精力去写一堆语言的规则呢！\n然后就找到了 KDE Framework 里的 KSyntaxHighlighting。KDE Framework 是真的烦人，刚开始怎么也 build 不出来。等到了 GitHub Actions 上，整整用了四天时间才搞定，还是在某 Packman 的帮助下才完成的。。。当时看到绿绿的 Actions，我差点没开心得疯掉。。\n这个 KSyntaxHighlighting，deepin-editor 和 Qt Creator 都在使用。好在他自己也提供了一些 example，看上去很简单。依赖也很小，只有 Extra CMake Modules，不过看上去和高亮的功能没啥关系，也许是 KF 必备依赖吧。它自带了两百多种语言的高亮规则，省了我很多事情，有 Dark / Light 主题，不服还可以自己写。很满意。\nCI 我可不想每次更新都自己打一次包，没那个闲心，手上能用的系统也不够 :) 穷孩子怎么买得起 Mac。所以只能用 CI 啦。\n现在 CI 主要帮我解决了：\nWindows 安装程序 Windows 上的 7z \u0026amp; MacOS 上的 dmg \u0026amp; Linux 的 AppImage Release 时自动上传以上所有文件 CI 平台当然是选择了 GitHub Actions 啦！现在这个项目所有环节都在 GitHub 上能找到，AUR 除外 :(\nNotepanda 的 CI 全都是抄 Qv2ray 上的，可真是帮了我很多忙。\n最后 感谢 Qv2ray 的 Super Packman: ymshenyu，感谢死鬼 gcc，感谢鸭鸭，感谢 Qv2ray User Group 里面的每一个人。如果没有他们，我的 Qt 旅程不会这么顺利。\n顺便，Qv2ray 是一个很好用的 v2ray 跨平台客户端，欢迎尝试！\n谢谢阅读 🙇‍♂️\n最后，放上我画的一只小熊猫：\n","date":"May 2020","permalink":"https://blog.chungzh.cn/articles/notepanda/","tags":["文本编辑器","Qt","C++"],"title":"Notepanda 开发小结"},{"categories":"瞎搞开发","contents":"在开发中经常需要测量时间，比如性能优化时，比较两种方法的耗时。除此之外，获取当前的时间也可以用于初始化随机数生成器。而 C++ 提供了很种方法来获取时间。\n标准库 std::time 定义 这个函数会返回一个距离 UTC 时间 1970 年 1 月 1 日 0:00 的秒数。\n头文件：\u0026lt;ctime\u0026gt;\n文档：std::time\n1 std::time_t time( std::time_t* arg ); 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { time_t res_1 = time(nullptr); Sleep(1000); // do some stuff... time_t res_2 = time(nullptr); cout \u0026lt;\u0026lt; res_1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; asctime(localtime(\u0026amp;res_1)) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; res_2 - res_1 \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* 输出结果 1585457981 Sun Mar 29 12:59:41 2020 1s */ std::chrono::steady_clock::now 定义 返回表示当前时间的时间点。\n这个时钟是专门用来计算时间的间隔的。C++ 还提供了一个 system_clock，用于获取系统的时间。\n头文件：chrono\n文档：std::chrono::stadey_clock\n1 2 static std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; now() noexcept; // (C++11 起) 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { chrono::steady_clock::time_point start = chrono::steady_clock::now(); Sleep(1000); // do some stuff... chrono::steady_clock::time_point end = chrono::steady_clock::now(); chrono::duration\u0026lt;double\u0026gt; ans = end - start; cout \u0026lt;\u0026lt; ans.count() \u0026lt;\u0026lt; \u0026#39;s\u0026#39; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1.01495s */ Windows GetTickCount 定义 检测自系统启动以来经过的毫秒数，最多为 49.7 天。如果不够用，可以使用 GetTickCount64。\n文档：GetTickCount function\n1 DWORD GetTickCount(); 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { DWORD start = GetTickCount(); Sleep(1000); // do some stuff... DWORD end = GetTickCount(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /*输出： 1016ms */ GetTickCount64 定义 检测自系统启动以来经过的毫秒数。\n文档：GetTickCount64 function\n1 ULONGLONG GetTickCount64(); 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { ULONGLONG start = GetTickCount64(); Sleep(1000); // do some stuff... ULONGLONG end = GetTickCount64(); cout \u0026lt;\u0026lt; end - start \u0026lt;\u0026lt; \u0026#34;ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1015ms */ QueryPerformanceCounter 定义 检测性能计数器的当前值，该值是一个高分辨率（\u0026lt;1us）时间戳，可用于时间间隔测量。\n这个函数是一个「黑科技」，精度非常高，用起来也稍微麻烦一点点。\n文档：QueryPerformanceCounter function\n用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { LARGE_INTEGER freq; QueryPerformanceFrequency(\u0026amp;freq); // 获取性能计数器的频率 LARGE_INTEGER start; QueryPerformanceCounter(\u0026amp;start); Sleep(1000); // do some stuff... LARGE_INTEGER end; QueryPerformanceCounter(\u0026amp;end); double misTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000000.0); // 微秒 double milTime = (end.QuadPart - start.QuadPart) / (freq.QuadPart / 1000.0); // 毫秒 double sTime = (end.QuadPart - start.QuadPart) / freq.QuadPart; // 秒 cout \u0026lt;\u0026lt; misTime \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; milTime \u0026lt;\u0026lt; \u0026#34; milliseconds\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sTime \u0026lt;\u0026lt; \u0026#34; seconds\u0026#34; \u0026lt;\u0026lt; endl; return 0; } /* 输出： 1.00367e+06 microseconds 1003.67 milliseconds 1 seconds */ 至此，本文共介绍了五种测量时间段的方法。\n作者很菜，如发现什么问题，请在评论区中指出。\n谢谢 🙇‍♂️\nReference Kurt Guntheroth. Optimized C++: Proven Techniques for Heightened Performance\nCppReference\nMicrosoft Docs\n","date":"March 2020","permalink":"https://blog.chungzh.cn/articles/cpp-get-time/","tags":["C++","Windows","时间"],"title":"Windows 中 C++ 测量时间的 N 种方法"},{"categories":"瞎搞开发","contents":" 0x00 介绍 tabulate tabulate 是一个使用 C++ 17 编写的库，它可以制作表格。使用它，把表格对齐、格式化和着色，不在话下！你甚至可以使用 tabulate，将你的表格导出为 Markdown 代码。下图是一个使用 tabulate 制作的表格输出在命令行的样例：\n当然，除了表格，你还可以玩出花样。看见下面这个马里奥了吗？这也是用 tabulate 制作的！源码在 这里。\n0x10 准备 首先你需要安装 CMake。\n创建一个文件夹（下文用 X 代替），作为你使用 tabulate 的地方。再将 include 这个文件夹下载到 X 里。然后在 X 里创建 main.cpp 以及一个 CMakeLists.txt。\n注意：需要下载 include 整个文件夹而不是仅仅下载 tabulate 文件夹\n你可以点击 这里 下载 tabulate 项目，然后将 include 文件夹复制到 X 中。\n将下面的代码复制进 CMakeLists.txt ：\n1 2 3 4 5 6 7 8 9 10 11 cmake_minimum_required(VERSION 3.8) # 这里的 tabulateDemo 可以换为你喜欢的名字 project(tabulateDemo) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED True) include_directories(include) add_executable(main main.cpp) 最后 X 文件夹的结构应该是这样的：\n1 2 3 4 5 . ├── CMakeLists.txt ├── include │ └── tabulate └── main.cpp 请认真核对好 X 的结构！\n可前往 ChungZH/tabulatedemo 核对文件结构。\n0x20 小试身手 将下面这段代码复制进 main.cpp 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table hellogithub; // 创建一个叫做 hellogithub 的 Table 对象 hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_style({fonttyle::underline}); hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } 如果你使用的是 Linux/MacOS 系统，请在终端进入 X 文件夹并输入以下命令：\n1 2 3 4 5 mkdir build cd build cmake .. make ./main 如果你使用的是 Windows 系统和 MinGW，请检查是否安装 mingw32-make.exe，并在终端中进入 X 文件夹，输入：\n1 2 3 4 5 mkdir build cd build cmake .. mingw32-make ./main.exe 如果你使用 Windows 以及 MSVC，在终端中输入：\n1 2 3 mkdir build cd build cmake .. 然后使用 Visual Studio 打开 build 文件夹下的 tabulateDemo.sln 来运行。\n如果没有问题，那么你应该会在终端里看到：\n0x30 格式化表格 请先认真分析 0x20 小试身手 章节中的代码并尝试着修改一下它！\n0x31 Word Wrapping 为了防止表格中的内容过长导致不整齐，你可以指定表格每一列的宽度，tabulate 就会自动帮你换行。语法如下：\n1 2 // 将表格第 0 行第 0 列的宽度设为20 table[0][0].format().width(20); 除了自动换行，你也可以在内容中使用 \\n 来手动设置换行。\n这是一个 Word Wrapping 的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;This paragraph contains a veryveryveryveryveryverylong word. The long word will break and word wrap to the next line.\u0026#34;, \u0026#34;This paragraph \\nhas embedded \u0026#39;\\\\n\u0026#39; \\ncharacters and\\n will break\\n exactly where\\n you want it\\n to\\n break.\u0026#34;}); table[0][0].format().width(20); // 设置第 0 行第 0 列的宽度为 20 table[0][1].format().width(50); // 设置第 0 行第 1 列的宽度为 50 cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; endl; return 0; } return 0; } 第 0 行第 0 列的文字是不是很长？但是设置了它的宽度后，就不用担心了。tabulate 将会帮你自动换行。如果不设置的话，表格就会变得很不整齐，你也可以尝试一下。\n第 0 行第 1 列的内容里运用了\\n 的换行符，所以即使我们给它设置了 50 的宽度，也会先根据内容里的 \\n 换行符来换行。\n值得注意的是，tabulate 会自动删除每一行内容两边的空白字符。\n0x32 字体对齐 tabulate 支持三种对齐设置：左、中和右。默认情况下，全部内容都会靠左对齐。\n要手动设置对齐方式，可以使用 .format().font_align(方向)。\n举一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace std; using namespace tabulate; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format() .font_align(FontAlign::center); // 设置居中对齐 hellogithub.add_row({\u0026#34;hellogithub.com\u0026#34;}); hellogithub[1][0].format() .font_align(FontAlign::left); // 设置靠左对齐 hellogithub.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub[2][0].format() .font_align(FontAlign::center); // 设置居中对齐 hellogithub.add_row({\u0026#34;xueweihan NB!!!\u0026#34;}); hellogithub[3][0].format() .font_align(FontAlign::right); // 设置靠右对齐 hellogithub[0][0].format().width(50); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } 0x33 字体样式 tabulate 支持以下八种字体样式：\n粗体 bold\n深色 dark\n斜体 italic\n下划线 underline\n闪烁 blink （？）\n翻转 reverse\n隐藏 concealed\n删除线 crossed\n某些样式可能会因为终端的原因而无法显示。\n如：粗体、深色、斜体、闪烁等样式，请慎用。\n要使用这些样式，可以调用 .format().font_style({...})。样式也可以叠加使用。\n0x34 颜色 你可以对表格的字体、边框、角以及列分隔符号设置它们的前景或背景颜色。\ntabulate 支持 8 种颜色：\n灰色 gray\n红色 red\n绿色 green\n黄色 yellow\n蓝色 blue\n洋红色 magenta\n青色 cyan\n白色 white\n可以通过 .format().\u0026amp;lt;element\u0026amp;gt;_color(颜色) 的方式定义前景色或通过 .format().\u0026amp;lt;element\u0026amp;gt;_background_color(颜色) 的方式定义背景色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table colors; colors.add_row({\u0026#34;Font Color is Red\u0026#34;, \u0026#34;Font Color is Blue\u0026#34;, \u0026#34;Font Color is Green\u0026#34;}); colors.add_row({\u0026#34;Everything is Red\u0026#34;, \u0026#34;Everything is Blue\u0026#34;, \u0026#34;Everything is Green\u0026#34;}); colors.add_row({\u0026#34;Font Background is Red\u0026#34;, \u0026#34;Font Background is Blue\u0026#34;, \u0026#34;Font Background is Green\u0026#34;}); colors[0][0].format() .font_color(Color::red) .font_style({fonttyle::bold}); colors[0][1].format() .font_color(Color::blue) .font_style({fonttyle::bold}); colors[0][2].format() .font_color(Color::green) .font_style({fonttyle::bold}); colors[1][0].format() .border_left_color(Color::red) .border_left_background_color(Color::red) .font_background_color(Color::red) .font_color(Color::red); colors[1][1].format() .border_left_color(Color::blue) .border_left_background_color(Color::blue) .font_background_color(Color::blue) .font_color(Color::blue); colors[1][2].format() .border_left_color(Color::green) .border_left_background_color(Color::green) .font_background_color(Color::green) .font_color(Color::green) .border_right_color(Color::green) .border_right_background_color(Color::green); colors[2][0].format() .font_background_color(Color::red) .font_style({fonttyle::bold}); colors[2][1].format() .font_background_color(Color::blue) .font_style({fonttyle::bold}); colors[2][2].format() .font_background_color(Color::green) .font_style({fonttyle::bold}); cout \u0026lt;\u0026lt; colors \u0026lt;\u0026lt; endl; return 0; } 0x35 边框、角 你可以对表格的边框和角的文本、颜色或背景颜色进行自定义。\n你可以使用 .corner(..)、.corner_color(..) 和 corner_background_color(..) 来对所有的角设置一个共同的样式。你也可以使用 .border(..) 、.border_color(..) 和 .border_background_color(..) 来对所有的边框设置一个共同的样式。\n这是一个单独设定所有边框和角的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;tabulate/table.hpp\u0026gt; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;ᛏᚺᛁᛊ ᛁᛊ ᚨ ᛊᛏᛟᚱy ᛟᚠᚨ ᛒᛖᚨᚱ ᚨᚾᛞ\\n\u0026#34; \u0026#34;ᚨ ᚹᛟᛚᚠ, ᚹᚺᛟ ᚹᚨᚾᛞᛖᚱᛖᛞ ᛏᚺᛖ\\n\u0026#34; \u0026#34;ᚱᛖᚨᛚᛗᛊ ᚾᛁᚾᛖ ᛏᛟ ᚠᚢᛚᚠᛁᛚᛚ ᚨ ᛈᚱᛟᛗᛁᛊᛖ\\n\u0026#34; \u0026#34;ᛏᛟ ᛟᚾᛖ ᛒᛖᚠᛟᚱᛖ; ᛏᚺᛖy ᚹᚨᛚᚲ ᛏᚺᛖ\\n\u0026#34; \u0026#34;ᛏᚹᛁᛚᛁᚷᚺᛏ ᛈᚨᛏᚺ, ᛞᛖᛊᛏᛁᚾᛖᛞ ᛏᛟ\\n\u0026#34; \u0026#34;ᛞᛁᛊcᛟᚹᛖᚱ ᛏᚺᛖ ᛏᚱᚢᛏᚺ\\nᛏᚺᚨᛏ ᛁᛊ ᛏᛟ cᛟᛗᛖ.\u0026#34;}); table.format() .multi_byte_characters(true) // Font styling .font_style({fonttyle::bold, fonttyle::dark}) .font_align(FontAlign::center) .font_color(Color::red) .font_background_color(Color::yellow) // Corners .corner_top_left(\u0026#34;ᛰ\u0026#34;) .corner_top_right(\u0026#34;ᛯ\u0026#34;) .corner_bottom_left(\u0026#34;ᛮ\u0026#34;) .corner_bottom_right(\u0026#34;ᛸ\u0026#34;) .corner_top_left_color(Color::cyan) .corner_top_right_color(Color::yellow) .corner_bottom_left_color(Color::green) .corner_bottom_right_color(Color::red) // Borders .border_top(\u0026#34;ᛜ\u0026#34;) .border_bottom(\u0026#34;ᛜ\u0026#34;) .border_left(\u0026#34;ᚿ\u0026#34;) .border_right(\u0026#34;ᛆ\u0026#34;) .border_left_color(Color::yellow) .border_right_color(Color::green) .border_top_color(Color::cyan) .border_bottom_color(Color::red); std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; return 0; } 0x36 基于范围的迭代 一个一个设置表格的样式是不是很麻烦？tabulate 提供了迭代器，支持对表、行和列的迭代，更方便地格式化表格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;tabulate/table.hpp\u0026gt; using namespace tabulate; int main() { Table table; table.add_row({\u0026#34;Company\u0026#34;, \u0026#34;Contact\u0026#34;, \u0026#34;Country\u0026#34;}); table.add_row({\u0026#34;Alfreds Futterkiste\u0026#34;, \u0026#34;Maria Anders\u0026#34;, \u0026#34;Germany\u0026#34;}); table.add_row({\u0026#34;Centro comercial Moctezuma\u0026#34;, \u0026#34;Francisco Chang\u0026#34;, \u0026#34;Mexico\u0026#34;}); table.add_row({\u0026#34;Ernst Handel\u0026#34;, \u0026#34;Roland Mendel\u0026#34;, \u0026#34;Austria\u0026#34;}); table.add_row({\u0026#34;Island Trading\u0026#34;, \u0026#34;Helen Bennett\u0026#34;, \u0026#34;UK\u0026#34;}); table.add_row({\u0026#34;Laughing Bacchus Winecellars\u0026#34;, \u0026#34;Yoshi Tannamuri\u0026#34;, \u0026#34;Canada\u0026#34;}); table.add_row({\u0026#34;Magazzini Alimentari Riuniti\u0026#34;, \u0026#34;Giovanni Rovelli\u0026#34;, \u0026#34;Italy\u0026#34;}); // 设置每一行的宽度 table.column(0).format().width(40); table.column(1).format().width(30); table.column(2).format().width(30); // 遍历第一行中的单元格 for (auto\u0026amp; cell : table[0]) { cell.format() .font_style({fonttyle::underline}) .font_align(FontAlign::center); } // 遍历第一列中的单元格 for (auto\u0026amp; cell : table.column(0)) { if (cell.get_text() != \u0026#34;Company\u0026#34;) { cell.format() .font_align(FontAlign::right); } } // 遍历表格中的行 size_t index = 0; for (auto\u0026amp; row : table) { row.format() .font_style({fonttyle::bold}); // 轮流把整行的背景设为蓝色 if (index \u0026gt; 0 \u0026amp;\u0026amp; index % 2 == 0) { for (auto\u0026amp; cell : row) { cell.format() .font_background_color(Color::blue); } } index += 1; } std::cout \u0026lt;\u0026lt; table \u0026lt;\u0026lt; std::endl; } 0x37 嵌套表格 在 tabulate 中嵌套表格很容易，因为 Table.add_row(...) 这个函数可以接受 std::string 类型和 tabulate::Table。下面是一个嵌套表格的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0] .format() .font_background_color(Color::blue) .font_align(FontAlign::center); Table hglink; hglink.add_row({\u0026#34;GitHub repo\u0026#34;, \u0026#34;Website\u0026#34;}); hglink.add_row({\u0026#34;github.com/521xueweihan/HelloGitHub\u0026#34;, \u0026#34;hellogithub.com\u0026#34;}); hellogithub.add_row({hglink}); // 嵌套！ cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl; return 0; } 0x40 导出 0x41 Markdown 可以使用 MarkdownExporter 来将一个表格导出为 GFM 风格的 Markdown。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;tabulate/markdown_exporter.hpp\u0026#34; // 注意这个头文件 #include \u0026#34;tabulate/table.hpp\u0026#34; using namespace tabulate; using namespace std; int main() { Table hellogithub; hellogithub.add_row({\u0026#34;HelloGitHub\u0026#34;}); hellogithub[0][0].format().font_style({fonttyle::bold}); // 加粗样式，在 Markdown 中可以表现出来 hellogithub.add_row({\u0026#34;GitHub repo: github.com/521xueweihan/HelloGitHub\u0026#34;}); hellogithub.add_row({\u0026#34;Website: hellogithub.com\u0026#34;}); // 导出为 Markdown MarkdownExporter exporter; auto markdown = exporter.dump(hellogithub); cout \u0026lt;\u0026lt; hellogithub \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Markdown Source:\\n\\n\u0026#34; \u0026lt;\u0026lt; markdown \u0026lt;\u0026lt; endl; return 0; } 导出效果如下：\nHelloGitHub GitHub repo: github.com/521xueweihan/HelloGitHub Website: hellogithub.com 注意：Markdown 不能指定每一个单元格的对齐样式，只能指定一列的对齐样式，像这样 hg.column(1).format().font_align(FontAlign::center);。\n0x50 尾声 如果想要更详细地了解 tabulate 的用法，请查看官方文档 https://github.com/p-ranav/tabulate 。\n本文是作者的第一次关于此类型文章的尝试，如有不足之处，请指正，谢谢！\n再见！\n","date":"February 2020","permalink":"https://blog.chungzh.cn/articles/tabulate/","tags":["C++"],"title":"优雅地使用 C++ 制作表格：tabulate"},{"categories":null,"contents":"","date":"January 0001","permalink":"https://blog.chungzh.cn/archives/","tags":null,"title":"Archives"},{"categories":null,"contents":" 我 就是个菜鸡。\n今年初三。\n关于本站 本站使用 Hugo 搭建。详见： GitHub: ChungZH.github.io。\n如无特殊说明，本站的内容均使用 CC BY-NC-SA 2.5 协议。\n","date":"January 0001","permalink":"https://blog.chungzh.cn/about/","tags":null,"title":"关于"},{"categories":null,"contents":"欢迎加友链哦！先友后链~\n有意者欢迎前往 GitHub - ChungZH.github.io 提交一个 PR，在本页面加上你的链接。或者发邮件给我也是可以的哦！邮箱是：chungzh07[AT]gmail.com。\nKoufan keithxodoy 泫 大尾巴苏卡卡的有底洞 GogesL zzzmh JunzhouLiu j0ck1e Alliot\u0026rsquo;s blog CareyQ Zidone Yi-yun Alpha1022 Vigorous Pro 左手的世界 PRIN BLOG Artin\u0026rsquo;s Blog EpLiar Coelacanthus Louis Aeilot\u0026rsquo;s blog Molink Eritque arcus Moody\u0026rsquo;s 收藏夹：\n%%%%%%\nmatrix67 很多有趣的数学题 Menci\u0026rsquo;s OI blog M_sea xht37 wjyyy Siyuan ","date":"January 0001","permalink":"https://blog.chungzh.cn/friends/","tags":null,"title":"友链"}]