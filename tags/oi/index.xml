<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OI on ChungZH's Blog</title><link>https://blog.chungzh.cn/tags/oi/</link><description>Recent content in OI on ChungZH's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 13 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.chungzh.cn/tags/oi/index.xml" rel="self" type="application/rss+xml"/><item><title>斜率优化 DP 笔记</title><link>https://blog.chungzh.cn/articles/slope-opt-dp/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/slope-opt-dp/</guid><description>例题 [HNOI2008]玩具装箱 Luogu LOJ
题目描述 P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。
P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。
为了方便整理，P 教授要求：
在一个一维容器中的玩具编号是连续的。
同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。
制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。
$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。
朴素 DP 做法 令状态 $f(i)$ 表示把前 $i$ 个玩具装箱的最小费用，$s(i)$ 为 $c_i$ 的前缀和。
假如将玩具 $j$ 到 $i$ 装在同一箱子，容易列出状态转移方程 $f(i) = \min_{1\le j\le i}{f(j-1)+(i-j+s(i)-s(j-1)-L)^2}$。</description></item><item><title>点分治笔记</title><link>https://blog.chungzh.cn/articles/centroid-decomposition/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/centroid-decomposition/</guid><description>点分治，外国人称之为 Centroid decomposition，重心分解。
何为树的重心 学习重心分解之前，自然要先了解重心。
下面统一用 $n$ 表示树上结点的个数。
在一棵树中，如果删除一个顶点后得到的最大子树的顶点数最少，那么这个点就是树的重心（Centroid）。
重心的性质：
删除重心后得到的所有子树，其顶点数必然不超过 $n/2$。
证明：选取任意顶点作为起点，每次都沿着边向最大子树的方向移动，最终一定会到达某个顶点，将其删除后得到的所有子树的顶点数都不超过 $n/2$。如果这样的点存在的话，那么也就可以证明删除重心后得到的所有子树的顶点数都不超过 $n/2$。
记当前顶点为 $v$，如果顶点 $v$ 已经满足上述条件则停止。否则，与顶点 $v$ 邻接的某个子树的顶点数必然大于 $n/2$。假设顶点 $v$ 与该子树中的顶点 $w$ 邻接，那么我们就把顶点 $w$ 作为新的顶点 $v$。不断重复这一步骤，必然会在有限步停止。这是因为对于移动中所用的边 $(v, w)$，必有 $v$ 侧的子树的顶点数小于 $n/2$，$w$ 侧的子树的顶点数大于 $n/2$，所以不可能再从 $w$ 移动到 $v$。因而该操作永远不会回到已经经过的顶点，而顶点数又是有限的，所以算法必然在有限步终止。
树中所有顶点到某个顶点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。
更多证明请见：树的重心的性质及其证明 - suxxsfe - 博客园 (cnblogs.com)
寻找树的重心 根据重心的定义，先以 $1$ 为根进行 DFS。在递归中计算子树大小 $siz[u]$，并求出最大的子树的大小 $maxs[u]$，比较出重心 $centroid$。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void getCentroid(int u, int fa, int s) { siz[u] = 1; maxs[u] = 0; for (int i = head[u]; i !</description></item><item><title>关于 int 与 long long 的运算速度</title><link>https://blog.chungzh.cn/articles/int-vs-longlong/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/int-vs-longlong/</guid><description>前言 写一道 CF 题的时候，算法明明是正确的，却一直都 TLE。最后把一个 long long 类型的数组改成了 int，竟然就 AC 了。。
这不禁引发了我的思考，int 与 long long 的运算速度不一样吗？
不严谨测试 由于本菜鸡并没有什么计算机基础原理的知识，只好做了一个测试。当然，这个测试其实很不严谨，没有很大的参考价值。我也就图一乐，哈哈哈哈哈
测试环境 电脑：Lenovo Yoga 14sACH 2021 系统：Windows 11 25163.1010 CPU：AMD Ryzen 7 5800H with Radeon Graphics (16) @ 3.200GHz RAM：16.0 GB 编译器：GCC 11.2.0 代码 仅仅是为了图一乐， 我第一次使用了 Google Benchmark 这一工具。其实挺好上手的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include &amp;lt;benchmark/benchmark.</description></item><item><title>Treap 笔记</title><link>https://blog.chungzh.cn/articles/treap/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/treap/</guid><description>Treap = Tree + Heap
二叉搜索树（BST） 在学习 Treap 之前，需要先了解一下二叉搜索树（BST, Binary Search Tree）：
设 $x$ 是二叉搜索树中的一个结点。如果 $y$ 是 $x$ 左子树中的一个结点，那么 $y.key \lt x.key$。如果 $y$ 是 $x$ 右子树中的一个结点，那么 $y.key \gt x.key$。
BST 上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 $n$ 个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\log n)$，最坏为 $O(n)$。随机构造这样一棵二叉搜索树的期望高度为 $O(\log n)$。然而，当这棵树退化成链时，则同样的操作就要花费 $O(n)$ 的最坏运行时间。
由于普通 BST 容易退化，对于它的实现就不再赘述。在实践中需要使用如 Treap 这样的平衡二叉搜索树。
Treap 顾名思义，Treap 是树和堆的结合。它的数据结构既是一个二叉搜索树，又是一个二叉堆。
在 Treap 的每个结点中，除了 $key$ 值，还要保存一个 $fix$（更常见的是 $priority$）值。这个值是随机值，以它为依据来同时建立最大堆（或最小堆）。因为 $fix$ 值是随机的，所以可以让这棵树更加平衡，高度更接近 $O(\log n)$。它的各种操作期望时间复杂度都是 $O(\log n)$。
旋转式 Treap 旋转式 Treap 的常数较小。
旋转 左旋/右旋操作不会破坏 BST 的性质，并可以通过它来维护堆，使树平衡。</description></item><item><title>CSP-J 2021 游记</title><link>https://blog.chungzh.cn/articles/csp2021/</link><pubDate>Sat, 23 Oct 2021 18:35:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/csp2021/</guid><description>CSP-J/S 认证注意事项：
&amp;hellip;&amp;hellip;
11. 祝各位选手好运。
CSP-J1 初赛前有点小紧张。
赛前勉强做了几套试卷，然后就上考场了。
刚考完对答案的时候发现 J 组才 72，看洛谷上大家都说今年 J 组简单了 blabla，分数线肯定会升，然而我却觉得好难，那一个星期都害怕极了。。。结果分数出来了才发现洛谷那群人真是扯啊哈哈哈
S 组才 48 分，没有成功压线。（其实就算去了复赛也拿不了分。。
CSP-J2 比赛前一晚上八点在学校出发。逃掉了晚自习（尽管是星期五
去到酒店大概也九点半了，洗完澡，看了会儿凤凰台，然后就睡了。
第二天早上六点半起床，吃完自助餐（和上一年的变化不大，挺好吃的），七点二十出发。
然后进考场。
电脑好像是 Ryzen 3600，8GB 内存。
八点半开考。
密码很乱，6ewid\n16384#，监考员一开始还直接忽略最后面那个井号了。。。
打开题目，发现第一第二题题面好长，有点慌了起来&amp;hellip;
T2 尤为毒瘤，到了 9:22 才搞完了。。。感觉挺很危险的，好怕翻车。
10:08，肝完 T3，77 行代码，写完人都瘫了。。感谢第三个样例，一个一个找情况。。。
（不知道怎么比对两个文件的内容，于是直接打开 Sublime Text 开始用查找来找不同。。。
赶紧吃了根士力架，然后去上了个厕所。
10:55，T4 过样例了，打得比 T3 轻松多了，当然也不可能拿满分。。。其实也不知道该怎么做，直接乱搞，做法非常诡异。。看看效果怎样吧，能骗到 50 分就是胜利。
还有一点，今年 NOI Linux 2 还行。（毕竟上一年给了虚拟机但是系统有密码，根本打不开，笑死）在里面编译了几次代码，虽然也没什么用。运行起来还蛮快的。
总的来说，这次考得还行。题目有点诡异，没有 dp，没有搜索，个人感觉侧重考基本功。
等成绩吧。
UPD 1 (2021/10/23 22:50)：
广东源代码出了。
candy: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &amp;lt;bits/stdc++.</description></item><item><title>线段树笔记</title><link>https://blog.chungzh.cn/articles/segment-tree/</link><pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/segment-tree/</guid><description>线段树是一种高端的数据结构，可以用来在区间上进行信息统计。它能够在 $O(logN)$ 的时间复杂度内实现单点/区间修改、区间找最大值/最小值/总和/&amp;hellip;，适用于大规模的区间统计。
如下图就是一棵线段树。在结点中，你可以存对应区间的最大值，最小值，总和等等。
对于每一个结点 $i$，它的两个子结点分别是 $2i$ 和 $2i+1$。因此，在开树的数组时，最好要开到 $4N$ 的大小。
关于 $4N$，详见 OI-Wiki。
建树 下面是一个求区间和的线段树的建树代码。
通过 DFS 建树，到叶结点，然后一路回溯求出和。
1 2 3 4 5 6 7 8 9 10 11 12 13 void build_tree(int cur, int left, int right) { // cur 为当前树的根，[left, right] 是当前树对应的区间 if (left == right) { // 到叶子节点了，区间长度为 1，总和就是它本身 tree[cur] = a[left]; return ; } int leftSon = cur*2, rightSon = leftSon+1; int mid = (left+right)/2; build_tree(leftSon, left, mid); build_tree(rightSon, mid+1, right); tree[cur] = tree[leftSon]+tree[rightSon]; // 求和 } 这里求 leftSon，rightSon，mid 的模式在线段树的所有操作中都会用到。</description></item><item><title>CSP-J 2020 游记</title><link>https://blog.chungzh.cn/articles/csp-j-2020/</link><pubDate>Sat, 14 Nov 2020 17:15:00 +0000</pubDate><guid>https://blog.chungzh.cn/articles/csp-j-2020/</guid><description>他山之石，可以攻玉。
CSP-J1 入学你校几乎两个月都在搞初赛。
结果初一还是只有两个人过了
最后是 73.5 分，水过去了。
CSP-J2 Day 0 要去大学城的广大附中，就去住酒店了。
在 tjl 大佬房间里 玩，其实是在看凤凰台。
依稀记得那晚上拜登和特朗普的比分是 264 : 214，林郑去北京见韩正了。
CCTV-7 上面中科院在帮农民种橘子？
十点多就回去昏昏沉沉地睡了，还挺香（
Day 1 早上六点半就醒了。
在酒店吃了顿自助早餐，真香。
到处都是石实的大佬 %%% 。
然后搭着同校热心家长的车前往广大附中。
门口还挺热闹的，好像发生了许多事情：
黄老师身份证不见了，其实藏在袋子里 某大佬没带准考证 还有没带粤康码的 于是感到很庆幸，没入考场的时候也是一场考验。。所以说带齐资料很重要。
很快就进考场了。
电脑有 8G 内存，装的是 Windows 10 神州网信政府版，感觉只是开始菜单看上去稍有不同。
下发题目之后几分钟我还在打 A+B，打完之后才一愣一愣地抄密码解压题目。
翻了一下，发现第一题好难，于是从第二题开始做。
T2 刚开始竟然用了 sort，到了最后试大样例的时候才看到一卡一卡的，于是又改成了插入排序，以为没问题了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; bool cmp(int a, int b) { return a &amp;gt; b; } int a[100005]; int main() { int n, w; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;w); for (int i = 0; i &amp;lt; n; i++) { int inp; scanf(&amp;#34;%d&amp;#34;, &amp;amp;inp); int j = 0; for (; j &amp;lt; i; j++) { if (a[j] &amp;lt; inp) break; } for (int k = i; k &amp;gt;= j; k--) { a[k+1] = a[k]; } a[j] = inp; int planNum = max(1, (int)((i+1)*0.</description></item></channel></rss>